17-aug-23 

 Database :- 
 --------------

 => a db is a organized collection of interrelated data ,for ex a  
      bank db stores data related to customers,accounts,trans etc
      and a univ db stores data related to students,courses,faculty etc

  Types of Databases :- 
  -----------------------------

  1  OLTP DB  (online transaction processing db)
  2  OLAP DB  (online analytical processing db)

 => organizations uses OLTP for storing day-to-day transactions and
      OLAP for analysis.

 => OLTP is for running business and OLAP is for to analyze business.

 => day-to-day operations on db includes

    C    create
    R    read
    U    update
    D    delete

 DBMS :- 
 -----------

 => DBMS stands for Database Management System.
 => It is a software used to create and to manage database.
 => DBMS is an interface between user and database.
 
Evolution of dbms :- 
---------------------------
 
 1960		fms   (file mgmt system)
 1970		hdbms (hierarchical dbms)
		     ndbms (network dbms)
 1980		rdbms  (relational dbms)
 1990		ordbms (object relational dbms)

 Data Models :- 
 ----------------------

 1 hierarchical
 2 network
 3 relational 
 4 object relational

Relational Model :- 
---------------------------

 =>  relational model introduced by E.F.CODD
 =>  E.F.CODD introduced 12  rules called codd rules.
 =>  a dbms that supports all 12  rules called perfect rdbms.
 
 information rule :- 
 -------------------------

 => according to information rule data must be organized in tables  
      i.e rows and columns 

      customers
      cid     name      age     city
      10     sachin     30       mum
      11     rahul        40       del
      12     vijay         25       hyd

       Database  =   collection of tables
       TABLE     =   collection of rows and columns
       ROW       =   collection of field values
       COLUMN    =   collection of values assigned to one field

  => every table must contain primary key to uniquely identify the records
 
      ex :-  accno,empid,aadharno,panno,voterid,vehno

 RDBMS features :- 
 ------------------------

 1 easy to access and manipulate data
 2 less redundency (duplication of data)
 3 more security
 4 gurantees data quality or data consistency
 5 supports data sharing 
 6 supports transactions (ACID properties) 

   A    atomocity
   C    consistency
   I    isolation
   D    durability

 RDBMS softwares :- 
 ---------------------------

 oracle                  from oracle corp
 mysql                   from oracle corp
 sql server              from microsoft
 db2                     from ibm
 postgresql              from postgresql forum development
 rds                     from amazon

  ORDBMS :- 
  ----------------

  => Object Relational DBMS.
  => it is the combination of RDBMS & OOPS.
          ORDBMS =  RDBMS + OOPS (reusability)
 => in ORDBMS also data organized in tables i.e. rows and cols
 => RDBMS doesn't support reusability but ORDBMS supports reusability.

 ordbms softwares :- 
--------------------------
 oracle
 sql server
 postgresql 

DB Development Life Cycle :- 
-----------------------------------------
 Analysis
 Design
 Development
 Testing
 Implementation
 Maintenance

 Design :- 
 ------------

 => Designing db means  designing tables  
 => DB is designed by DB Designer or  DB Architect
 => DB is designed by using 

  1  ER  Model (Entity Relationship)
  2  Normalization 

 Development :- 
 --------------------

 => DB Development means creating tables in db.
 => DB is developed by   Developers & DBAs (DB Admin) by using any rdbms.
      tool like oracle,mysql etc.
 
              Developers			    DBAs

             creating tables		    installation of oracle		
             creating views            creating db 
             creating synonyms         creating userids 
             creating sequences        db backup & restore
             creating indexes          db export & import
             creating procedures       db upgradation & migration
             creating functions        performance tuning                     
             creting packages
             creating  triggers
             writing queries

    oracle 11g ver  =========> 19c/21c         upgradation

    mysql  ==================> oracle          migration 

 => DB is tested by QA (Quality Assurance) team by using some tools called testing tools

=> Implementation means moving db from Dev server to PROD server.

 summary :- 
 ---------------

 what is db ?
 what is dbms ?
 what is rdbms ?
 what is ordbms ?
 what is db development life cycle ?

==========================================================

 => oracle is basically a rdbms product from oracle corp and also supports
      features of ordbms and used to manage database.

 => oracle can be used for both development and administration.

 versions of oracle :- 
 --------------------------
 1,2,3,4,5,6,7,8i,9i,10g,11g,12c,18c,19c,21c,23c 

          i   =>  internet
          g  =>  grid
          c  =>  cloud 

 => from 8 onwards suffix "i" is added because oracle supports internet applications
 => grid means collection of servers , from 10g onwards oracle db can be
      accessed through mutliple servers and advantage of grid is if one 
      server is down we can access db through another server.
 => from 12c onwards oracle db can deployed in
      1   on premises server
      2   on cloud  server
 => in " on premises "  db is deployed in the server managed by client.
 => in " on cloud " db is deployed in the server managed by cloud 
     service provider for ex amazon.
 
             AMAZON       	AWS  (AMAZON WEB SERVICES)
             MICROSOFT	     AZURE
             GOOGLE		     GCP   (GOOGLE CLOUD PLATFORM)
             ORACLE           OCI    (ORACLE CLOUD INFRASTRCTURE)

CLIENT/SERVER Architecture :- 
-------------------------------------------
 1 server
 2 client 

 server :- 
 ------------
  => server is a system where oracle is installed and running
  => in server oracle manages following two memories

        1  INSTANCE
        2  DB

  => instance is created in ram and acts as temporary storage
  => db is created in hard disk and acts as permanent storage

client :- 
----------
 => client is also a system where users can

   1 connects to server
   2 submit requests 
   3 receive response

 client tools :- 
 ----------------
 
 SQLPLUS (cui)
 SQL DEVELOPER (gui)

 USER------SQLPLUS----------------------------ORACLE-------DB


 SQL :-
 ---------
 
 => SQL stands for structured query language.
 => language used to communicate with oracle.
 => user communicates with oracle by sending commands called queries.
 => a query is a command/instruction/question submitted to oracle to
      perform some operation over db.
=>  SQL is originally introduced by IBM and initial name of this lang was
      "SEQUEL"  and later it is renamed to SQL.
 => SQL is common to all rdbms softwares. 

   USER---SQLPLUS---------------SQL-------------------ORACLE------DB

   USER---MYSQLWORKBENCH----------SQL---------MYSQL-------DB

   USER---SSMS------------------------SQL-----------------SQL SERVER---DB

=> based on the operations over db SQL is divided into following sublanguages

       	 DDL (DATA DEFINITION LANG)
	 DML (DATA MANIPULATION LANG)
	 DQL (DATA QUERY LANG)
	 TCL  (TRANSACTION CONTROL LANG)
	 DCL (DATA CONTROL LANG)
		
		               		 SQL

 	DDL		   DML	     DQL	     TCL		   DCL
  
	CREATE	  INSERT	     SELECT	COMMIT	   GRANT
	ALTER	  UPDATE		          ROLLBACK	   REVOKE
	DROP		  DELETE		          SAVEPOINT
	TRUNCATE	  MERGE
	RENAME	  INSERT ALL
	FLASHBACK
	PURGE
 
  DATA & DATA DEFINITION :- 
  --------------------------------------
 
EMPID   ENAME      SAL         DATA DEFINITION
   1	A	6000       DATA 

  note :-   

   => SQL is not case sensitive 
   => sql commands must be terminated with ';' 
   
 SCHEMA :- 
 ----------------

  => schema means user.
  => a user in oracle db is called schema.
  => objects created by user are called schema objects for ex tables.
          
  SERVER
          DATABASE
                      USER
                            TABLE
                                    DATA
  
  SERVER
          ORCL 
                 SYS                          (DBA)
                 SYSTEM/TIGER       (DBA)

 How to connect to oracle :- 
 ------------------------------------

  => to connect to oracle open sqlplus 

     USERNAME   :-  SYSTEM
     PASSWORD  :-  TIGER

    OR

     USERNAME  :-   SYSTEM/TIGER

 SQL> 

 creating user/schema/account in oracle db :- 
 ----------------------------------------------------------

 => only DBAs are having permissions to create new user

 step 1 :-  connect  as SYSTEM/TIGER

         USERNAME :-  SYSTEM/TIGER

 step 2 :- create user

       CREATE USER <NAME> IDENTIFIED BY <PWD>
       DEFAULT TABLESPACE USERS
       QUOTA UNLIMITED ON USERS ;

 EX :- 

   SQL>CREATE USER BATCH730 IDENTIFIED BY ORACLE
            DEFAULT TABLESPACE USERS
            QUOTA UNLIMITED ON USERS;

 step 3 :- granting permissions 

     SQL>GRANT CONNECT,RESOURCE TO BATCH730;

              CONNECT    =>  to connect to db
              RESOURCE =>  to create tables 
              DBA              =>   all permissions 
    
           GRANT DBA TO VIJAY ; 


 how to download oracle 21c 
 -------------------------------------
 Editions :- 
 ---------------

 1 Enterprise Edition
 2 Express Edition

 

 1  GOOGLE :- oracle 21c express edition download 

 2  open the link ORACLE DATABASE (XE) EDITION

 3  download oracle21c_win64

4  downloads zip file

5  copy the zip file to a new folder on desktop 

6 select zip file => select extract here

7 double click setup (application)

installation :- 
-------------------

 google :-  step by step installation of oracle 21c express edition

 DATATYPES IN ORACLE :- 
 --------------------------------------

 => Datatype specifies 

     1  type of the data allowed in a column
     2  amount of memory allocated for column

 			          DATATYPES

 	CHAR		   NUMERIC	 DATE		BINARY
	 
  ASCII          UNICODE            number(p)	date		  bfile
                                    number(p,s)	timestamp	  blob
 char	       nchar
 varchar2        nvarchar2
 long            nclob
 clob

char(size) :- 
-----------------

 => allows character data upto 2000 chars 
 => recommended for fixed length char columns

  ex :-   NAME     CHAR(10)

            sachin----
                          wasted

           ravi------ 
                          wasted 

 => in char datatype extra bytes are wasted , so char is not recommended
      for variable length fields and it is recommended for fixed length fields

    ex :-    gender      char(1)
  
               m
               f

              state_code  char(2)

              AP
              TS

             country_code  char(3)

                IND
                USA
  
VARCHAR2 :- 
------------------

 => allows character data upto 4000 chars.
 => recommended for variable length fields 

  ex :-       NAME    VARCHAR2(10)

                sachin----
	             released

 => char/varchar2 allows ascii chars (256 chars) that includes 
      a-z,A-Z,0-9,special chars.
 
           ex  :-    panno   char(10)
                     ehno    char(10)
                     email   varchar2(20)

LONG :- 
 ------------

=> allows character data upto 2GB

  ex :-  reviews   LONG

CLOB :-     (character large object)
-------------

=> allows character data upto 4GB

   ex :-   feedback   CLOB 

nchar/nvarchar2/nclob :-      (n  => national)
---------------------------------

=> allows unicode chars (65536 chars)  that includes chars of different
     languages.

Number(p) :- 
-----------------

 => allows numeric data upto 38 digits
 => allows integers i.e. numbers without decimal

  ex  :-     empno    number(4)
  
               10
               100
               1000
               10000  => not allowed

              aadharno   number(12)

              accno        number(11)

              phone       number(10)

 Number(p,s) :- 
 ---------------------

  => allows numbers contains decimal i.e. float
 
 p => precision => total no of digits allowed
 s => scale  =>  no of digits allowed after decimal

   ex :-     salary   Number(7,2)

              5000
              5000.55
              50000.55  
              500000.55  => not allowed 

DATE :- 
------------

  => allows date & time  
  => time is optional , if not entered then oracle stores 12:00AM
  => default date format in oracle is DD-MON-YY / YYYY

   ex  :-    DOB    DATE

              15-AUG-03     =>  15-AUG-2003 00:00:00
              10-OCT-98     =>   10-OCT-2098
              10-OCT-1998  =>   10-OCT-1998
 
 => date occupies 7 bytes 

      INPUT :-  DD-MON-YYYY

      STORES :-  DD   MM   YYYY  HH  MI  SS
                 1    1     2     1  1    1 

TIMESTAMP :- 
--------------------

=> allows date,time,milliseconds and also timezone

   ex :-   T     TIMESTAMP

            25-AUG-23 8:12:20.123  AM +5:30
           ---------- ----------   -- -------
            DATE         TIME      MS  TZ

 => memory varies from 9 to 13 bytes depends on milliseconds

 Binary Types :- 
 ------------------

  => binary types allows  multimedia objects like audio,video,images 
   
 1 BFILE (binary file )
 2 BLOB  (binary large object)
    
 => BFILE is called external lob because lob stored outside db but db stores
      path called locator.

 => BLOB is called internal lob because lob stored inside db.

 creating tables in db :-
 -----------------------------

 CREATE TABLE <tabname>
 (
    colname  datatype(size),
    colname  datatype(size),
    -------------------------
  );

 ex :- 

 CREATE TABLE emp
 (
   empid   NUMBER(4),
   ename  VARCHAR2(10),
   job        VARCHAR2(10),
   sal        NUMBER(7,2),
   doj        DATE,
   dname  VARCHAR2(10)
 );

 => above command created table structure / definition / metadata that
      includes columns,datatype and size.

 DESC :-  (DESCRIBE)
 ------------------------------

  => command used to display table structure
 
     ex :-     DESC  EMP

               EMPID                NUMBER(4)
               ENAME                VARCHAR2(10)
               JOB                  VARCHAR2(10)
               SAL                  NUMBER(7,2)
               DOJ                  DATE
               DNAME                VARCHAR2(10)


 inserting data into table :- 
 -------------------------------
 
=> "insert" command is used to insert data into table.
=> we can insert 

   1  single row
   2  multiple rows 

 inserting single row :- 
 ---------------------------

         INSERT INTO <tabname> VALUES(v1,v2,v3,----) ;

  ex :- 

 1    INSERT INTO emp VALUES(100,'sachin','clerk',5000,'26-AUG-23','hr');
 2    INSERT INTO emp VALUES(101,'arvind','manager',8000,SYSDATE,'sales');

inserting multiple rows :- 
-------------------------------

 => to execute insert command multiple times with different values use variables 
      prefixed with "&".

 ex :- 

 SQL>INSERT INTO emp VALUES(102,'vijay','analyst',&sal,&doj,&dname);
Enter value for empid: 102
Enter value for ename: 'vijay'
Enter value for job: 'analyst'
Enter value for sal: 10000
Enter value for doj: '10-MAR-20'
Enter value for dname: 'it'

1 row created.

SQL> /   (executes previous command)
Enter value for empid: 103
Enter value for ename: 'sindhu'
Enter value for job: 'manager'
Enter value for sal: 9000
Enter value for doj: '20-OCT-19'
Enter value for dname: 'hr'

NOTE :- above insert commands inserted data into instance (ram) which is temporary
 storage , to save this data execute commit command.

   SQL>COMMIT;

  => in normal exit operations are saved and in abnormal exit operations are not saved

    SQL>EXIT ;  (normal exit)

 inserting nulls :- 
 ----------------------

 => null means blank or empty
 => it is not equal to 0 or space
 => nulls can be inserted in two ways 

 method 1 :- 
 ---------------

  SQL>INSERT INTO emp VALUES(105,'ravi','',null,'12-JAN-21','it');
  
 method 2 :- 
 ---------------

  SQL>INSERT INTO emp(empid,ename,doj,dname) VALUES(106,'bhanu',sysdate,'sales');
 
  remaining two fields filled with nulls

28-aug-23 

 Operators in oracle :- 
 -----------------------------

 Arithmetic Operators  =>  +    -     *      / 
 Relational Operators  =>  >  >=   <    <=    =    <>(not equal to)
 Logical Operators     =>  AND  OR   NOT  
 Special Operators     =>  BETWEEN
                           IN
                           LIKE
                           IS
                           ANY
                           ALL
                           EXISTS
                           PIVOT
 Set Operators         =>  UNION
                           UNION ALL
                           INTERSECT
                           MINUS
                                        
Displaying Data :- 
-----------------------
 
=> "SELECT" command is used to display data from table.
=> we can display all rows or specific rows
=> we can display all cols or specific cols

 syn :-  SELECT  columns / *    FROM  tabname ; 

            sql     =    english 
           queries =  sentences
           clauses =   words

=> display all the data from emp table ?

     SELECT * FROM emp ; 

=> display employee names and salaries ? 

    SELECT ename,sal FROM emp ; 

=> employee names,jobs,doj ?

    SELECT ename,job,doj FROM emp ; 
      
WHERE clause :- 
------------------------

=> used to get specific row/rows from table based on a condition.

     SELECT columns
     FROM tabname
     WHERE condition ; 

 condition :- 
 ---------------

            COLNAME  OP   VALUE

  => op must be any relational operator like >  >=  <   <=   =   <> 
  => if cond = true row is selected , if false row is not selected
 
 => display employee details whose id = 103 ?

      SELECT * FROM emp WHERE empid = 103 ; 
 
  => employee details whose name = kumar ? 

     SELECT * FROM emp WHERE ename = 'kumar' ;

=> employees earning more than 5000 ?

    SELECT * FROM emp WHERE sal > 5000;

=> employees joined after 2020 ?

      SELECT * FROM emp WHERE doj > 2020 ;  => ERROR 

     SELECT * FROM emp WHERE doj > '31-DEC-2020' ; 

=> employees joined before 2020 ?

     SELECT * FROM emp WHERE doj  < '01-JAN-2020' ; 

=> employees not working for  sales dept ?

     SELECT * FROM emp WHERE dname <> 'sales' ;

     SELECT * FROM emp WHERE dname <> 'SALES' ; => no rows

 note :-  in oracle strings are case sensitive i.e. lowercase and uppercase
 strings are not same.

 compound condition :- 
 -----------------------------
 
 => multiple conditions combined with AND / OR operators is called
      compound condition.

     WHERE  cond1  AND   cond2         result
	    T	          T	             T
                     T                     F                  F
                     F                     T                  F
                     F                     F                  F

   WHERE	   cond1  OR    cond2            result
	    T	        T		T
                     T	        F                        T
                     F                   T                        T
                     F                   F                        F
 
 => employees working as clerk,manager ?

     SELECT * FROM emp WHERE job='clerk' OR job='manager' ;  

 => employees working for sales dept and earning more than 5000 ?

    SELECT * FROM emp WHERE dname='sales' AND sal>5000; 
    
29-AUG-23

 => employees whose id = 100,103,105 ? 

     SELECT * FROM emp WHERE empid=100  OR   empid = 103  OR empid=105 ; 

=> employees earning more than 5000 and less than 10000 ?

    SELECT * FROM emp WHERE sal > 5000    AND      sal < 10000 ; 
       
 => employees joined in 2020 year ?

     SELECT * FROM emp WHERE doj >= '01-JAN-2020'   AND  doj <= '31-DEC-2020' ;

=> 

   STUDENT
   SNO   SNAME  S1   S2    S3
   1        A             80    90    70
   2       B              30   60    50

  list of students who are passed ? 

  SELECT * FROM STUDENT WHERE  S1>=35 AND  S2>=35  AND S3>=35 ;

  list of students who are failed ?

  SELECT * FROM STUDENT WHERE  S1<35  OR  S2<35   OR  S3<35 ;

 Testing :- 

 SQL>CREATE TABLE STUDENT
     (
      SID NUMBER(2),
      SNAME VARCHAR2(10),
      S1  NUMBER(3),
      S2  NUMBER(3),
      S3  NUMBER(3)
   );

SQL> INSERT INTO STUDENT VALUES(&SID,&SNAME,&S1,&S2,&S3);


=> display employees working as clerk,manager and earning more than 5000 ?

   SELECT * FROM emp WHERE job='clerk'  
                                                       OR
                                                       job='manager'
                                                      AND
                                                      sal>5000 ;

   above query returns clerk records earning 5000 because operator AND has
   got more priority then operator OR , so sal>5000 applied only to manager but
   not to clerk, to overcome this problem use  (   )

    SELECT * FROM emp WHERE (
                                                        job='clerk'  
                                                        OR
                                                        job='manager' 
                                                        )
                                                        AND
                                                       sal>5000 ;

 IN operator :- 
--------------------

 => use IN operator for  list comparision.
 => use IN operator for "=" comparision with multiple values.

         WHERE COLNAME  =  V1,V2,V3,---     =>   INVALID
         WHERE COLNAME  IN (V1,V2,V3,--)   => VALID
 
        WHERE COLNAME <> V1,V2,V3,----    =>  INVALID
        WHERE COLNAME NOT IN (V1,V2,V3,---)  => VALID

 => employees whose id = 100,103,105  ? 

      SELECT * FROM emp WHERE empid IN (100,103,105) ;

  => employees not working for dept hr,sales ?

     SELECT * FROM emp WHERE dname NOT IN ('hr','sales'); 

 BETWEEN operator :- 
 -----------------------------

 => use BETWEEN operator for range comparision
 
       WHERE COLNAME BETWEEN V1 AND V2   (COL>=V1 AND COL<=V2)

       WHERE COLNAME NOT BETWEEN V1 AND V2 

 => employees earning between 5000 and 10000 ?

     SELECT * FROM emp WHERE  sal BETWEEN 5000 AND 10000 ; 

=> who are not joined in 2020 ?

    SELECT * 
    FROM emp 
   WHERE doj NOT BETWEEN '01-JAN-2020' AND '31-DEC-2020' ;

 => employees working as clerk,manager and earning between 5000 and 10000
      and not joined in 2020 and not working for dept it,sales ?

     SELECT *
     FROM emp 
    WHERE job IN ('clerk','manager')
                  AND
                  sal BETWEEN 5000 AND 10000
                  AND
                  doj NOT BETWEEN '01-JAN-2020' AND '31-DEC-2020'
                  AND
                  dname NOT IN ('it','sales') ;

=> 

  products
  prodid  pname  price  category   brand  

 list of samsung,redmi,realme mobile phones price between 10000 and 20000 ?

 SELECT *
 FROM products
 WHERE  brand IN ('samsung','redmi','realme')
                 AND
                 price  BETWEEN 10000 AND 20000
                 AND
                 category='mobiles'  ; 

 30-aug-23

 LIKE operator :- 
 ---------------------

 => use LIKE operator for pattern comparision
 
     ex :-  name starts with 's'
              emailid ends with '.in'
              job contains space

        WHERE  COLNAME  LIKE  'PATTERN'

 => pattern contains alphabets,digits,wildcard chars

 wildcard chars :- 
 ---------------------

    %   =>  0 or many chars

    _   =>  exactly 1 char
 
  => employees name starts with 's'  ?

      SELECT * FROM emp WHERE ename LIKE  's%' ; 

 => employees name ends with 'd' ?

     SELECT * FROM emp WHERE ename LIKE '%d' ;

 => employees name contains 'a' ? 

       SELECT * FROM emp WHERE ename LIKE  '%a%' ; 

 => where 'a' is the 3rd char in their name ?

      SELECT  *  FROM emp WHERE ename LIKE '__a%' ; 

 => 'a' is the 3rd char from last ?

     SELECT  *  FROM emp WHERE ename LIKE '%a__'  ;

=> name contains 4 chars ? 

     SELECT  *  FROM emp WHERE ename LIKE '____'  ; 

=> employees joined in JAN month ?      DD-MON-YY

     SELECT * FROM emp WHERE doj LIKE '%JAN%' ; 
 
=> employees joined in 2020 year ?

   SELECT * FROM emp WHERE doj LIKE '%20' ; 
  
    SELECT * FROM emp WHERE doj LIKE '_______20' ;

 Question 1  :- 
 --------------

  SELECT *  
  FROM emp 
  WHERE job IN ('clerk','man%') ;

A  ERROR
B  returns clerk,manager rows
C  returns only clerk rows
D  none

  ANS :-  C      =>   %man  is not treated as pattern because operator is IN

 WHERE job='clerk' OR job LIKE 'man%'  ;

 ANS :-  B 

Question 2 :- 
-------------------

  SELECT *
  FROM emp 
  WHERE sal BETWEEN 10000 AND 5000 ; 

 A  ERROR
 B RETURNS ROWS
 C RETURNS NO ROWS
 D  NONE

  ANS :-  C 
 
 WHERE SAL BETWEEN 5000 AND 10000   (SAL>=5000 AND SAL<=10000)

 WHERE SAL BETWEEN 10000 AND 5000  (SAL>=10000 AND SAL<=5000)

 NOTE :- use BETWEEN with lower and upper  but not with upper and lower.

 scenario :- 
 ----------------

 CUST
 CID	CNAME
 10	sachin_tendulkar
 11	virat%kohli
 12	mahendra_singh_dhoni

 => cust list name contains "_"  ? 

   SELECT * FROM cust WHERE cname LIKE  '%_%' 

   above query returns all customer records because "_" is treated as wildcard char 
   but not treated as normal char , to overcome this problem use ESCAPE.

   SELECT * FROM cust WHERE cname LIKE  '%\_%'  ESCAPE '\' ;

   char that immediately follows "\" is not treated as wildcard char and it is treated as normal char

  => name contains "%"  ?

      SELECT * FROM cust WHERE cname LIKE  '%\%%'  ESCAPE '\'  ; 

 => name contains 2 "_"   ? 

    SELECT * FROM cust WHERE cname LIKE '%\_%\_%'   ESCAPE '\' ;

IS operator :- 
-------------------

 => use IS operator for NULL comparision

         WHERE COLNAME IS NULL
         WHERE COLNAME IS NOT NULL

 => employees not earning sal ? 

      SELECT * FROM emp WHERE sal  IS NULL ; 

 => employees who are earning sal ?

         SELECT * FROM emp WHERE sal  IS  NOT NULL ; 

 summary :- 

  WHERE COLNAME IN (V1,V2,V3,---)  
  WHERE COLNAME BETWEEN V1 AND V2
  WHERE COLNAME LIKE 'PATTERN'
  WHERE COLNAME IS NULL 

  ALIAS :-  
 -------------

 => alias means another name or alternative name.
 => used to change column heading.
 
       COLNAME /  EXPR   [AS]   ALIAS 

  => display   ENAME   ANNUAL SAL  ?

      SELECT ENAME,SAL*12 AS ANNSAL
      FROM EMP ; 

      SELECT ENAME,SAL*12 AS  "ANNUAL SAL"
      FROM EMP ; 

 => display ENAME  EXPERIENCE in years ? 

     SELECT ENAME,	ROUND((SYSDATE - doj)/365) AS EXPERIENCE 
     FROM EMP ; 

 => employees having more than 3 years of expr ? 

     SELECT ENAME,	ROUND((SYSDATE - doj)/365) AS EXPERIENCE 
     FROM EMP
     WHERE EXPERIENCE > 3 ;   => ERROR
 
   NOTE :-  alias cannot be used in where clause 

     SELECT ENAME,ROUND((SYSDATE - doj)/365) AS EXPERIENCE 
     FROM EMP
     WHERE ROUND((SYSDATE-doj)/365) > 3 ; 

 => display  ENAME  SAL  HRA   DA   TAX   TOTSAL   ? 

            HRA  =  house rent allowance  =  30% on sal
            DA     =  dearness allowance    =  20% on sal
            TAX   =  10% on sal
            TOTSAL = SAL + HRA + DA - TAX 

      SELECT  ENAME,SAL,
                      SAL*0.3 AS HRA,
                      SAL*0.2 AS DA,
                      SAL*0.1 AS TAX,
                      SAL + (SAL*0.3) + (SAL*0.2) - (SAL*0.1) AS TOTSAL
      FROM EMP ; 

           
    SACHIN	5000	1500	1000	500	7000
 
 ORDER BY :- 
 -------------------

 => used to sort table data based on one or more columns either in ascending or
      descending.

      SELECT columns
      FROM tabname
      [WHERE cond] 
      ORDER BY colname ASC / DESC  ,----- ,---   ; 

 => default order is ASC 

 => arrange employee list name wise asc ?

      SELECT *
      FROM emp
      ORDER BY ename  ASC ; 

  => arrange employee list sal wise desc ? 

       SELECT *
       FROM emp
       ORDER BY sal DESC ; 

       1	A	3000		2	B	6000
       2	B	6000  =========> 	3	C	5000
       3	C	5000		4	D	4000
       4	D	4000		1	A	3000

 01-sep-23

 => arrange employee list dept wise asc and with in dept sal wise desc ?

     SELECT empno,ename,sal,deptno
     FROM emp 
     ORDER BY deptno ASC,sal DESC ; 

    1	A	3000	10		4	D	5000	10
    2	B	6000	20		1	A	3000	10
    3	C	4000	30 ============>	2	B	6000	20
    4	D	5000	10		5	E	4000	20
    5	E	4000	20		6	F	7000	30
    6	F	7000	30		3	C	4000	30

=> arrange employee list dept wise asc and with in dept hiredate wise asc ?

    SELECT empno,ename,hiredate,deptno 
    FROM emp 
    ORDER BY deptno ASC,hiredate ASC ; 

scenario :- 
--------------

 STUDENT
 SNO	SNAME	M	P	C
 1	A	80	90	70
 2	B	60	70	50
 3	C	90	80	70
 4	D	90	70	80

=> arrange student list avg wise desc ,  m desc,p desc  ?

 SELECT SNO,SNAME,M,P,C,(M+P+C)/3  AS  AVG
 FROM STUDENT
 ORDER BY (M+P+C)/3  DESC,M DESC,P DESC ; 

 3	C	90	80	70	80
 4	D	90	70	80	80
 1	A	80	90	70	80
 2	B	60	70	50	60
 
 => display employees working as clerk,manager and arrange list sal wise desc order ?

      SELECT  empno,ename,job,sal
      FROM emp 
      WHERE job  IN ( 'CLERK','MANAGER' )
      ORDER BY sal DESC ; 

 EXECUTION :- 
 --------------------

 FROM
 WHERE
 SELECT
 ORDER BY 

FROM emp :-
-----------------
 
1	A	CLERK		3000
2	B	MANAGER	6000
3	C	ANALYST		5000
4	D	CLERK		5000

WHERE :-
---------------

1	A	CLERK		3000
2	B	MANAGER	6000
4	D	CLERK		5000


ORDER BY :-
--------------------

2	B	MANAGER	6000
4	D	CLERK		5000
1	A	CLERK		3000

=> display employees joined in 1981 and arrange list sal wise desc ?

    SELECT empno,ename,hiredate,sal
    FROM emp 
    WHERE hiredate LIKE  '%81' 
    ORDER BY sal DESC ; 
 
handling nulls in sorting :-
-----------------------------------

 => in order by   nulls treated high
 => in ascending order nulls displayed last
 => in descending orders nulls displayed first
 => to control this use NULLS  LAST/FIRST option

 ex :- 

  => arrange employee list comm wise desc but display nulls last ?

       SELECT empno,ename,sal,comm
       FROM emp 
       ORDER BY comm DESC  NULLS LAST ;

 => arrange employee list comm wise asc but display nulls first ?

       SELECT empno,ename,sal,comm
       FROM emp 
       ORDER BY comm ASC  NULLS FIRST ;
 
02-sep-23 

 DISTINCT clause :- 
 ---------------------------

 => Distinct clause eliminates duplicates from select stmt output.
 
             DISTINCT  column1
             DISTINCT  column1,column2,----
             DISTINCT  *

 ex :- 

 SQL>SELECT DISTINCT job FROM emp ;

   CLERK
   SALESMAN
   ANALYST
   MANAGER
   PRESIDENT

SQL>SELECT DISTINCT DEPTNO FROM EMP ;


        30
        10
        20

SQL>SELECT DISTINCT DEPTNO,JOB FROM EMP ; 
                                          --------------------

   	 DEPTNO  JOB
	---------- 	---------
        	20 	MANAGER
        	20 	ANALYST
        	10 	PRESIDENT
        	10 	CLERK
        	30 	SALESMAN
        	10 	MANAGER
        	20 	CLERK
        	30 	MANAGER
       	 30 	CLERK

 SQL>SELECT DISTINCT DEPTNO,DISTINCT JOB  FROM EMP ; => ERROR

 SQL>SELECT DEPTNO,DISTINCT JOB FROM EMP ;    => ERROR

NOTE :- 

 => distinct cannot be applied on individual fields
 => distinct cannot be applied on specific fields

FETCH clause :- 
------------------------

 => introduced in 12c ver
 => used to display top n rows from table.
 
=> display first 5 rows from emp ?
 
     SELECT empno,ename,sal
     FROM emp 
     FETCH FIRST 5 ROWS ONLY ; 

    FETCH FIRST 50 PERCENT ROWS ONLY ; 

 => display 5th rec to 10th rec ?

       SELECT empno,ename,sal
       FROM emp 
       OFFSET 4 ROWS FETCH NEXT 6 ROWS ONLY ; 

=>  display top 5 highest paid employees ?

       SELECT empno,ename,sal
       FROM emp 
       ORDER BY sal DESC
       FETCH FIRST 5 ROWS ONLY ; 

 => display top 5 employees based on experience ?

       SELECT empno,ename,hiredate
       FROM emp 
       ORDER BY hiredate ASC 
       FETCH FIRST 5 ROWS ONLY ; 

 =>  display top 3 max salaries ?

     SELECT DISTINCT SAL
     FROM EMP
     ORDER BY SAL DESC
     FETCH FIRST 3 ROWS ONLY ;

      5000
      3000
      2975

 summary :- 

 WHERE
 ORDER BY
 DISTINCT
 FETCH 
 
 DML commands :-   (Data Manipulation Lang)
 -------------------------

 insert
 update
 delete
 insert all
 merge

 => all DML commands acts on table data.
 => these operations are performed on instance i.e. temporary memory. 
 => to save these operations execute COMMIT. 
 => to cancel these operations execute ROLLBACK.

UPDATE command :- 
------------------------------

 => command used to modify table data.
 => we can update all rows or specific rows.
 => we can update  single column or multiple columns.

   syn :- 

    UPDATE <tabname>
    SET colname = value  ,  colname = value ,---------
    [WHERE cond] ;

 ex :- 

  => update all the employees comm with 500 ?

     UPDATE emp SET  comm = 500  ;

 => update employees comm with 500 whose comm = null ?

     UPDATE emp SET comm = 500  WHERE comm IS  NULL  ; 

 => update employees comm with null whose comm <> null ?

    UPDATE emp SET comm = NULL WHERE comm IS NOT NULL ; 

      NULL assignment   =
      NULL comparision  IS 

 => update employee sal with 2000 and comm with 500 whose empno = 7369 ?

     UPDATE emp 
     SET sal = 2000 ,comm = 500
     WHERE empno = 7369 ; 

 => increment sal by 20% and comm by 10% those working as salesman and
      joined in 1981 year ?
 
     UPDATE emp 
     SET sal = sal + (sal *0.2)  ,  comm = comm + (comm*0.1)     
     WHERE job='SALESMAN'
                    AND
                   hiredate LIKE '%81'; 

 04-SEP-23 

=>  increment all samsung,redmi,realme mobile phones price by 10%  ?

  PRODUCTS
  PRODID  PNAME   PRICE  CATEGORY  BRAND
 
  UPDATE products
  SET  price = price + (price *0.1) 
  WHERE brand IN ('samsung','redmi','realme')
                 AND
                 category='mobiles' ; 
 
 DELETE command :- 
 -----------------------------

 =>  command used to delete row/rows
 => we can delete all rows or specific rows

  syn :-  DELETE FROM <tabname> [WHERE cond] ; 

ex :- 

   => delete employees having more than 40 years of expr ?

       DELETE FROM emp WHERE (SYSDATE-hiredate)/365 > 40 ; 

 => delete employees joined in 1981 year ?

      DELETE FROM emp WHERE hiredate LIKE '%81' ; 

 => delete employees whose empno = 7369,7566,7844 ?

      DELETE FROM emp WHERE empno IN (7369,7566,7844); 

 FLASHBACK :- 
 ---------------------

 =>  introduced in 9i and extended in 10g ver
 =>  using flashback we can see the data that exists some time back  for ex 5 mins back.
 =>  a normal query returns current data.
 =>  a query that returns past data is called flashback query.
 =>  used to recover data after commit.

 syn :- 

       SELECT *
       FROM tabname
       AS OF TIMESTAMP(SYSDATE -  INTERVAL) ; 

ex :- 

   SELECT *
   FROM emp 
   AS  OF TIMESTAMP (SYSDATE - INTERVAL '5' MINUTE);


 NOTE :- 

  => by default we can flashback upto 15 mins (900 secs)
  => to alter this value execute the following command

 SYSTEM :- 
 --------------

  SQL>ALTER SYSTEM SET UNDO_RETENTION = 1800 ;  

                       1800 sec = 30 mins 

 recovering data after commit :- 
------------------------------------------

 STEP 1 :- delete all rows

 SQL>DELETE FROM EMP ; 

STEP 2 :-  save changes

 SQL>COMMIT;

STEP 3 :- recoverting data 

 INSERT INTO emp 
 SELECT *
 FROM emp 
 AS OF TIMESTAMP(SYSDATE - INTERVAL '5' MINUTE) ;

=> above query returns 5 mins back data and whatever data returned by query is
     inserted into  emp table.

 DDL commands :-   (Data Definition Lang)
 ------------------------

CREATE
ALTER
DROP
TRUNCATE
RENAME
FLASHBACK
PURGE

 => all  DDL  commands acts on table structure.
 => all DDL commands are auto committed.

               DDL command  =  DDL command + COMMIT 

 => DDL operations are implicitly committed by oracle where as DML commands are
      explicitly committed by user.

 ex 1 :- 

 create table a(a number(2));
 insert into a values(10);
 insert into a values(20);
 insert into a values(30);
 insert into a values(40);
 rollback ; 

 output :- 
 
  create table => saved
  inserts        => cancelled

ex  2 ; - 

 create table a(a number(2));   
 insert into a values(10);
 insert into a values(20);
 create table b(b number(2));   
 insert into a values(30);
 insert into a values(40);
 rollback ; 
 
output :- 

 create table a => saved
 insert 10,20   => saved
 create table b => saved
 insert 30,40   => cancelled

5-SEP-23
ALTER command :-
-------------------------

 => command used to modify the table structure
 => using ALTER command we can

 1 add columns
 2 drop columns
 3 rename a column
 4 modify a column

Adding a column :-
------------------

 => add column gender to emp table ? 

  ALTER TABLE emp
      ADD (gender CHAR(1));

=> after adding by default the new column is filled with nulls , to insert data into 
  the new column use update command.

  UPDATE emp SET gender='m' WHERE empno=7369;

  UPDATE emp SET gender='&gender' WHERE empno=&empno;

 Droping column :- 
 ---------------

 => drop column gender from emp table ?

  ALTER TABLE emp 
        DROP (gender) ;

 Renaming a column :- 
 --------------------

 => rename column comm to bonus ? 

  ALTER TABLE emp 
      RENAME COLUMN comm TO bonus ; 

  SELECT empno,ename,sal,comm as bonus
  FROM emp ;

 => diff b/w rename & alias ?

        rename				alias 

   1    permanent                      tempoarary

   2    changes column name            changes column heading in select stmt output
         in table

 Modifying a column :- 
 ----------------------

 1 incr/decr field size
 2 changing datatype

=> increase size of ename to 20 ?

  ALTER TABLE emp 
        MODIFY(ename VARCHAR2(20));

=> decrease size of ename to 10 ? 

 ALTER TABLE emp 
        MODIFY(ename VARCHAR2(10));

  ALTER TABLE emp 
        MODIFY(ename VARCHAR2(5));  => ERROR (some name contains more than 5 chars)

NOTE :- 

 1  column must be empty to decrease precision or scale of numeric field

  ALTER TABLE emp
    MODIFY (sal  NUMBER(6,2));  => error

 2 column must be empty to change datatype 

   ALTER TABLE emp
      MODIFY(empno VARCHAR2(10));  => error
 
08-sep-21

 DROP command :- 
 ----------------

 => command used to drop table from database.
 => drops table structure with data.

  syn :- DROP TABLE <tabname>

  ex :-  DROP TABLE emp ; 
 
 => prior to 10g ver when table is dropped it is removed permanently and from 10g onwards
   when table is dropped it is moved to recyclebin.

 => to see the recyclebin execute the following command

  SQL>SHOW RECYCLEBIN ;

 FLASHBACK command :- 
 ---------------------

 => introduced in 10g 
 => command used to restore the table from recyclebin.
 
  syn :- 

  FLASHBACK TABLE <tabname> TO BEFORE DROP ; 
 
  Ex :- 

  FLASHBACK TABLE emp TO BEFORE DROP ; 

 => table is restored with columns and rows that exists before drop.
 
 PURGE command :- 
 -----------------

 => command used to delete object from recyclebin.
 => after deleting table from recyclebin flashback will not work.

  syn :-  PURGE TABLE <tabname> 

  Ex :-   PURGE TABLE emp;

          PURGE RECYCLEBIN ;  => deletes all the objects from recyclebin.

          DROP TABLE emp PURGE ; => drops table and also deleted  from recyclebin

06-SEP-23 

TRUNCATE :- 
------------------

 => deletes all the data from table but keeps structure.
 => will empty the table.
 => releases memory allocated for table.

 syn :-  TRUNCATE TABLE <tabname> ;

 ex  :-   TRUNCATE TABLE emp ; 

  => when above command is executed oracle goes to memory and
       releases all the blocks allocated for the table and when blocks are
       released data stored in blocks also deleted.

 drop vs delete vs truncate :- 
 ------------------------------------

         DROP			 DELETE/TRUNCATE

   drops structure with data                        deletes only data but not structure

DELETE VS TRUNCATE :- 
-----------------------------------

	DELETE				TRUNCATE

1	DML				 DDL

2              can delete specific rows                            can't delete specific rows

3              where cond can be                                   where cond cannot 
                used with delete                                        be used with truncate

4              operation can be rolledback                      operation cannot be rolledback

5              we can flashback data                               flashback will not work
                after delete                                                after truncate

6              deletes row-by-row                                    deletes all rows at a time

7               will not release memory                            releases memory

8                slower                                                      faster

RENAME :- 
---------------

 => command used to change tablename

    syn :-  RENAME  <oldname> TO <newname>;

    ex :-    RENAME emp TO employees ; 

 Built-in Functions in ORACLE  :- 
 ---------------------------------------

 => a function accepts some input performs some calculation and returns one value

 Types of functions :- 
 --------------------------

 1 single row  functions
            char
            numeric
            date
            conversion
            special
            analytical
 2 multi row functions

character functions :- 
----------------------------

upper() :- 

 => function used to convert string to uppercase

         upper(arg)

ex :- 

 SELECT UPPER('hello')  FROM DUAL ;   =>  HELLO

 what is DUAL ?

 =>  DUAL is a dummy table provided by oracle used to select non db values.
 =>  DUAL table contains 1 row & 1 column

07-SEP-23

LOWER() :- 
----------------

=> converts string to lowercase.

          LOWER(arg)

ex :- 

 SQL>SELECT LOWER('HELLO') FROM DUAL ;   =>   hello

=> display  EMPNO	 ENAME	SAL  ?  display names in lowercase ?

   SQL>SELECT EMPNO,LOWER(ENAME) AS ENAME,SAL FROM EMP ; 

=> convert names to lowercase in table ?

   SQL>UPDATE emp SET ename = LOWER(ename) ;

=> display employee details whose name = BLAKE  ? 

    SELECT *
    FROM emp 
    WHERE ename = 'BLAKE'  ;  => no rows 

    in oracle string comparision is case sensitive but to perform case insensitive use
    UPPER / LOWER functions.

    SELECT *
    FROM emp 
    WHERE   UPPER(ename) = 'BLAKE'  ; 
 
    WHERE  LOWER(ename)='blake' ; 
  
 INITCAP() :- 
 -----------------

  => converts initials into capitals 

   SQL>SELECT INITCAP('hello welcome') FROM DUAL ;   => Hello Welcome

 LENGTH() :- 
 -----------------

 => returns string length i.e. no of chars 

             LENGTH(arg)

  SQL>SELECT LENGTH('hello welcome') FROM DUAL ;  => 13

=> display  ENAME    LENGTH    ?
 
     SELECT  ENAME,LENGTH(ENAME) AS LEN FROM EMP ; 

=> employees name contains 4 chars  ?

    SELECT *
    FROM EMP
    WHERE  ENAME LIKE '____'  ;

    WHERE LENGTH(ENAME) = 4 ; 

SUBSTR() :- 
---------------

 => used to extract part of the string.

        SUBSTR(string,start,[length])

 ex :- 

   SUBSTR('hello welcome',7,4)       =>  welc
   SUBSTR('hello welcome',7)          =>  welcome
   SUBSTR('hello welcome',10,3)     =>  com
   SUBSTR('hello welcome',-5,3)      =>  lco

=> employees name starts with 's'  ?

      WHERE ENAME LIKE  's%' ;

    SELECT * FROM emp WHERE SUBSTR(ename,1,1)='s' ; 

 => employees name starts and ends with same char ?

    SELECT * FROM emp WHERE ename LIKE 'a%a' 
                                                       OR
                                                       ename LIKE 'b%b'
                 
  SELECT *
  FROM emp   
  WHERE SUBSTR(ename,1,1)  =  SUBSTR(ename,-1,1) ; 
    
 => generate emailids as follows ?

  EMP
  EMPNO	  	ENAME		EMAILID
  7369		smith		smi736@tcs.com 
  7499		allen		all749@tcs.com

   'a'||'b'            => ab

   'a'||'    '||'b'     => a   b 

 SELECT empno,ename,
                SUBSTR(ename,1,3)||
                SUBSTR(empno,1,3)||
                '@tcs.com'  as emailid
FROM emp ;

=> store emailids in db ?

 STEP 1 :- add emailid column to emp table

     ALTER TABLE emp 
          ADD (emailid  VARCHAR2(20));

STEP 2 :- update the column with emailids

    UPDATE emp 
    SET emailid  =  SUBSTR(ename,1,3)||
                             SUBSTR(empno,1,3)||
                             '@tcs.com' ; 

 08-sep-23 

 INSTR() :- 
 -------------

 => returns position of a char in a string.

       INSTR(string,char,[start,occurance]) 

ex :- 

      INSTR('hello welcome','o')        =>  5

       h  e  l  l  o      w  e   l   c   o   m   e
       1  2 3 4 5  6  7   8  9  10 11 12  13

      INSTR('hello welcome','x')     =>  0 

      INSTR('hello welcome','o',1,2)   => 11

      INSTR('hello welcome','e',7,2)  =>  13

     INSTR('hello welcome','e',-1,3)   =>  2

=> display employee list name contains space ?

      WHERE ename LIKE  '% %'  ;

      SELECT *
      FROM emp 
      WHERE INSTR(ename,' ') <>  0 ;

 scenario :- 

 CUST
 CID	CNAME
 10	SACHIN TENDULKAR
 11	VIRAT KOHLI
 
display	CID	FNAME		LNAME	?

first name :-    
----------------

              SUBSTR(cname,1,INSTR(cname,' ')-1)

last name :- 
---------------

          SUBSTR(cname,INSTR(cname,' ')+1 )

  SELECT CID ,
                  SUBSTR(cname,1,INSTR(cname,' ')-1) AS FNAME,
                  SUBSTR(cname,INSTR(cname,' ')+1 ) AS LNAME
 FROM CUST ;
 
 10	SACHIN		TENDULKAR 
 11	VIRAT		KOHLI

 
Assignment :- 
-------------------

 CUST
 CID	CNAME
 10	SACHIN RAMESH TENDULKAR
 11	PUSALA VENKAT SINDHU

 display	CID	FNAME	  MNAME         LNAME    ?
 
LPAD & RPAD :- 
--------------------

 => both functions are used to fill string with a character

        LPAD(string,length,char)   => fills on left side
        RPAD(string,length,char)  => fills on right side

 ex :- 

     LPAD('hello',10,'*')               =>   *****hello
     RPAD('hello',10,'*')              =>   hello*****
     RPAD('*',10,'*')                    =>   **********

=> display  ENAME	SAL  ?
	                 ***
	                 ****
		 *****

     SELECT  ENAME,RPAD('*',LENGTH(SAL),'*')  AS SAL FROM EMP ;

scenario :- 
---------------

 ACCOUNTS
 ACCNO		BAL
 1234567896	10000


your  a/c no  XXXX7896 debited ----------- ? 

method 1 :- 

  LPAD(SUBSTR(ACCNO,-4,4),8,'X') 

method 2 :- 

  LPAD('X',4,'X')||SUBSTR(ACCNO,-4,4) 

 LTRIM,RTRIM,TRIM :- 
 -----------------------------

 => used to remove spaces and unwanted chars 

   LTRIM(string1,[string2])         =>  removes on left side
   RTRIM(string1,[string2])        =>  removes on right side
   TRIM(string)                          =>  removes both sides 

 ex :- 

     LTRIM('   hello    ')                =>    'hello     '
     RTRIM('   hello   ')                =>    '     hello'
     TRIM('   hello     ')                =>    'hello'
   
    LTRIM('@@@hello@@@','@')   		=>  hello@@@
    RTRIM('@@@hello@@@','@')  		=>  @@@hello
    TRIM(both '@' from '@@@hello@@@')  	=>  hello

 9-SEP-23 

  REPLACE() :- 
  ------------------

  => function used to replace one string with another string.

                REPLACE(str1,str2,str3) =>  in str1 ,  str2 replaced with str3 

 ex :- 

   REPLACE('hello','ell','abc')      =>     habco
   REPLACE('hello','l','abc')         =>     heabcabco
   REPLACE('hello','elo','abc')     =>      hello        
   REPLACE('@@he@@ll@@o@@','@','')   => hello

   TRANSLATE() :- 
   -----------------------

    => used to translate one char to another char

            TRANSLATE(str1,str2,str3)

ex :- 

  TRANSLATE('hello','elo','abc')     =>   habbc

              e  => a
              l   => b
              o  => c

 TRANSLATE('hello','elo','')            =>    null 

 =>  translate function canbe used to encrypt data  i.e. converting plain text to cipher text

  display	ENAME	SAL ?

  SELECT ENAME,
                 TRANSLATE(SAL,'0123456789','$kB*t^U@#%')  AS SAL 
  FROM EMP ; 
  
  JONES	2975   => B%@^

 =>   remove all special chars from  '@#he*^ll%$o*%' ?

   STEP 1 :- translate all special chars to one special char

          TRANSLATE( '@#he*^ll%$o*%' ,'@#$%^*','******')  => **he**ll**o**

  STEP 2 :-   replace '*' with null

    SELECT
    REPLACE(TRANSLATE( '@#he*^ll%$o*%' ,'@#$%^*','******') ,'*','')
    FROM DUAL ; 

 REVERSE() :- 
 -------------------

  => returns string reverse

       REVERSE(string) 

  ex :- REVERSE('hello')  => olleh

 => employees whose name is palindrome ?

       ex :-  nitin

    SELECT *
    FROM EMP
    WHERE ENAME = REVERSE(ENAME)  ;

 summary :- 

 upper,lower,initcap,length,substr,instr,ltrim,rtrim,trim,lpad,rpad,replace,translate,reverse

11-sep-23 

 Numeric functions :- 
 ---------------------------

 ABS() :- 
-----------

 => returns absolute value

           ABS(number)

    ABS(-10)         =>   10
    ABS(10)          =>    10

 POWER() :- 
 ---------------

  => returns power

            POWER(num1,num2) 

   POWER(3,2)    =>   9

 SQRT() :- 
 -------------

 => returns square root

      SQRT(number) 

  SQRT(16) => 4 

SIGN() :- 
------------

=>  used to test whether number is positive or negative

        SIGN(number)

     SIGN(10)           =>   1
     SIGN(-10)          =>  -1
     SIGN(10-10)      =>  0

 MOD() :- 
 ------------

  => returns remainder

          MOD(num1,num2) 

   MOD(10,2)    =>    0 

=> employees earning multiples of 100 ?

    SELECT *
    FROM EMP
    WHERE MOD(SAL,100) = 0 ; 

 Roudning numbers :- 
 ---------------------------

  ROUND
  TRUNC
  CEIL
  FLOOR

  ROUND() :- 
  ----------------

 => used to round number to integer or to decimal places based on avg.

                      ROUND(number,[decimal places]) 

 ex :- 

      ROUND(38.7)   =========>  39

      38---------------------38.5---------------------------39

     number >= avg  => rounded to highest
     number < avg    => rounded to lowest 

    ROUND(38.3)     ============>  38

   ROUND(38.5)     =============> 39

   ROUND(38.5678,2)     =========>   38.57

   ROUND(38.5637,2)     ==========> 38.56
 
  ROUND(38.5637,1)      ==========> 38.6

  ROUND(386,-2)            ===========> 400

  300--------------------------350--------------------------400

 ROUND(386,-1)            ===========>  390

  380-------------------------385---------------------------390

 ROUND(386,-3)          ===========>  0

  0----------------------------500----------------------------1000

=> what is the output of following query ?

   SELECT ROUND(4567,-1),ROUND(4567,-2),ROUND(4567,-3) FROM DUAL;

  o/p :-      4570                     4600                    5000
   
=> display  ENAME  EXPERIENCE in years ? 

     SELECT ENAME, ROUND((SYSDATE - HIREDATE)/365) AS EXPR 
     FROM EMP ; 

=> round employee salaries to hundreds in table ?

    UPDATE emp SET sal = ROUND(sal,-2) ; 

 TRUNC :- 
 -----------

  => always rounds number to lowest 

             TRUNC(number,[decimal places)

 ex :- 

    TRUNC(38.9)            =>      38 
    TRUNC(38.4567,2)   =>      38.45
    TRUNC(386,-2)        =>       300
    TRUNC(999,-3)        =>       0 
    
CEIL() :- 
------------

 => rounds number always to highest integer

        CEIL(number)

  ex :- 

        CEIL(3.1)        =>   4

FLOOR() :- 
--------------

  => rounds number to lowest integer

        FLOOR(number)

  ex :- 

    FLOOR(3.9)     =>   3 

DATE functions :- 
----------------------


sysdate + 10          =>  adds 10 days to sysdate
sysdate -10            =>  subtracts 10 days from sysdate
sysdate - hiredate   =>  calculates difference in days
sysdate + hiredate  =>  invalid

 MONTHS_BETWEEN() :- 
 ---------------------------------

 => calculates difference between two dates in months 

           MONTHS_BETWEEN(date1,date2) 

 ex :- 

    MONTHS_BETWEEN(SYSDATE,'11-SEP-2022')   =>  12

   => display  ENAME  EXPERIENCE in months ? 

       SELECT  ENAME,
              FLOOR(MONTHS_BETWEEN(SYSDATE,HIREDATE)) AS EXPR
       FROM EMP ;

 => display  ENAME   EXPERIENCE  ?
                                  M YEARS N MONTHS 

      experience = 40 months =  3 years 4 months 

      years   =    months/12  =  FLOOR(40/12) = 3 

     months =   MOD(months,12)  =  MOD(40,12)  = 4  

     SELECT  ENAME,
          FLOOR(MONTHS_BETWEEN(SYSDATE,HIREDATE)/12)  AS YEARS,
          MOD(FLOOR(MONTHS_BETWEEN(SYSDATE,HIREDATE)),12) AS MONTHS
    FROM EMP ; 
 
12-SEP-23

ADD_MONTHS() :- 
-------------------------

 => used to add / subtract months to / from a date 

            ADD_MONTHS(DATE,MONTHS) 

  ex :- 

 ADD_MONTHS(SYSDATE,2)     =>    11-NOV-23 
 ADD_MONTHS(SYSDATE,-2)    =>    11-JUL-23 

 ROUND & TRUNC :- 
 ---------------------------

 => round & trunc functions can also be used to round dates 
 => dates can be rounded to year / month / day 
            
               ROUND(date,'year / month / day')

 ex :- 

    ROUND(sysdate,'year')             =>   01-jan-24

    01-jan-23----------------------30-jun----------------------------01-jan-24

   ROUND(sysdate,'month')           =>  01-sep-23

   01-sep-23---------------------15-sep----------------------01-oct-23

   ROUND(sysdate,'day')               =>   10-sep-23 

  10-sep-23----------------------thu-------------------------------17-sep-23


  TRUNC(sysdate,'year')          =>   01-jan-23
  TRUNC(sysdate,'month')       =>   01-sep-23
  TRUNC(sysdate,'day')           =>   10-sep-23
  TRUNC(sysdate)                  =>    12-sep-23 00:00:00
 
  scenario :- 
  --------------

 SQL>INSERT INTO emp(empno,ename,sal,hiredate)  
                   VALUES(111,'ABC',3000,SYSDATE);

=> list of employees joined today ?

    SELECT * 
    FROM emp 
    WHERE hiredate = SYSDATE ;    =>  no rows

                  12-sep-23 7:54:00 =  12-sep-23 7:57:20

 => in the above example oracle not only compares date and it also compares
      time , to overcome this problem both sides apply TRUNC function.

    SELECT * 
    FROM emp 
    WHERE TRUNC(hiredate) = TRUNC(SYSDATE) ; 

                   12-SEP-23 00:00:00  =  12-SEP-23 00:00:00

=> 

  GOLD_RATES
  DATEID		RATE
  01-JAN-20	?
  02-JAN-20	?
  03-JAN-20	?

 12-SEP-23	?

 1  display today's gold rate ?
 2  display yesterday's gold rate ?
 3  display last month same day gold rate ?
 4  display last year same day gold rate ?

1

  SELECT * 
  FROM gold_rates
  WHERE TRUNC(dateid) = TRUNC(sysdate) ;

 2 

  SELECT * 
  FROM gold_rates
  WHERE TRUNC(dateid) = TRUNC(sysdate-1) ;

3

  SELECT * 
  FROM gold_rates
  WHERE TRUNC(dateid) = TRUNC(ADD_MONTHS(sysdate,-1));


4

  SELECT * 
  FROM gold_rates
  WHERE TRUNC(dateid) = TRUNC(ADD_MONTHS(sysdate,-12));

 5  display last 1  month gold rates ?

  SELECT * 
  FROM gold_rates
  WHERE  dateid BETWEEN  
               TRUNC(ADD_MONTHS(SYSDATE,-1))  AND  TRUNC(SYSDATE) ;


LAST_DAY() :- 
-------------------

 => returns last day of the month

               LAST_DAY(date) 

    LAST_DAY(sysdate)   =>   30-sep-23 

 
 1 display next month 1st day ?
 2 display current month 1st day ?
 3 display next year first day ?
 4 display current year first day ?

NEXT_DAY() :- 
---------------------

 => returns next day starting from given date.

                  NEXT_DAY(date,day)

 ex :- 

       NEXT_DAY(SYSDATE,'SUNDAY')        =>  17-SEP-23
       NEXT_DAY(SYSDATE,'TUESDAY')      =>  19-SEP-23

 => display first sunday of the next month ?
 => display current month last sunday ?

 summary :-  add_months,months_between,round,trunc,last_day,next_day

 conversion functions :- 
 ------------------------------

 => used to convert one datatype to another datatype
 => conversion is 2 types 

   1 implicit conversion
   2 explicit conversion

 implicit conversion :- 
 ----------------------------

 => if conversion performed by oracle then it is called implicit conversion.

 ex :- 

 1    SELECT   1000 + '5000'  FROM DUAL ;     => 6000

 =>  string '5000'  converted to number implicitly by oracle.

 2   SELECT add_months('12-SEP-23',2) FROM DUAL ; => 12-NOV-23

  => string '12-NOV-23' converted to date implicitly by oracle.

 note :- 

  1  sometimes implicit conversion fails 
  2  implicit conversion is not recommended because it degrades performance


13-sep-23

 Explicit conversion :- 
 ----------------------------

 => if conversion performed by user then it is called explicit conversion.

    1  TO_CHAR
    2  TO_DATE 
    3  TO_NUMBER

 converting date to char type :- 
 ----------------------------------------

 => dates are converted to char type to display dates in different formats

                     TO_CHAR(date,'format') 

   formats :-                             (date = sysdate)
   -------------
	 
   yyyy				2023		
       yy				23
   year				twenty twenty three
       cc				centuary (21)
  
     mm				09
     mon				sep
     month				september

     ddd				256 (day of the year)
       dd				13 (day of the month)
         d                                                          4  (day of the week)   sun-sat   (1-7)
         dy                                                        wed
         day                                                      wednesday
 
         hh				hour part
         hh24                                                    hour part in 24 hrs format
         mi				minutes
         ss				seconds

        Q				quarter	(1-4)

				 1    jan-mar
				 2    apr-jun
                                                                      3    jul-sep
                                                                      4    oct-dec

     w				 week of the month
     ww				 week of the year

     j                                                                returns date in julian format

    sp 				spelling

 
 => display employees joined in 1980,1983,1985 years ?

     SELECT *
     FROM 	emp 
     WHERE  TO_CHAR(hiredate,'yyyy')  IN (1980,1983,1985) ;

 => display employees joined in leap year ?

    SELECT *
    FROM emp 
    WHERE MOD(TO_CHAR(hiredate,'yyyy'),4)=0 ; 

  => display employees joined in jan,apr,dec months ?
  
    SELECT *
    FROM emp 
    WHERE TO_CHAR(hiredate,'mm')  IN (1,4,12) ; 

 => display smith joined on wednesday  
                   allen joined on friday  ?

      SELECT ename||' joined on '||TO_CHAR(hiredate,'day')
      FROM emp ;

 => display employees joined on sunday ?

    SELECT *
    FROM emp 
    WHERE TO_CHAR(hiredate,'dy') = 'sun' ; 

=> display employees joined in 2nd quarter of 1981 year ?

    SELECT *
    FROM emp 
    WHERE TO_CHAR(hiredate,'yyyy') = 1981
                   AND
                   TO_CHAR(hiredate,'q') =  2 ; 

   WHERE  TO_CHAR(hiredate,'YYYY-Q') =   '1981-2' ; 

 => display current date & time  ? 
 
   SELECT TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS PM') FROM DUAL ;

=> display current date as follows ?

     13 september 2023  , Wednesday  8:36 AM

  SELECT TO_CHAR(SYSDATE,'DD month YYYY , Day HH:MI AM') FROM DUAL ; 
      
=> display employees joined on sunday ?

      SELECT *
     FROM EMP
     WHERE TO_CHAR(HIREDATE,'DAY')='SUNDAY' ;  => NO ROWS 

    D   	 1 
    DY  	SUN
    DAY  	SUNDAY---

     SELECT *
     FROM EMP
     WHERE TO_CHAR(HIREDATE,'fmDAY')='SUNDAY' ; 
 
       fm  => format mask  => removes extra spaces 

  14-sep-23

 converting number to char type :- 
 --------------------------------------------

  => numbers converted to char type to display numbers in different formats 

          TO_CHAR(number,'format') 

  formats :-  
  ----------------

     9		=> represents a digit
     0		=> represents a digit
     G		=> thousand seperator
     D		=> decimal seperator
     L 		=> currency symbol
     C		=> currency

examples :- 
----------------

  TO_CHAR(1234,'99999') 	 	 =>    1234
  TO_CHAR(1234,'00000') 		 =>    01234
  TO_CHAR(1234,'999999')      		 =>    1234
  TO_CHAR(1234,'000000')      		 =>     001234
  TO_CHAR(1234,'9G999')        	 =>     1,234
  TO_CHAR(500000,'9G99G999')   	 =>     5,00,000
  TO_CHAR(1234,'9G999D99')		 =>     1,234.00
  TO_CHAR(1234,'L9G999')		 =>     $1,234
  TO_CHAR(1234,'C9G999')		 =>     USD1,234

       
 => display ENAME  SAL  ?   
      display  salaries with thousand seperator and currency symbol ?

     SELECT ENAME,TO_CHAR(SAL,'L99G999D99') AS SAL FROM EMP ; 
 
  how to change currency :-  
 ----------------------------------

   ALTER  SESSION SET NLS_TERRITORY = 'INDIA' ; 

   SELECT ENAME,TO_CHAR(SAL,'C99G999D99') AS SAL FROM EMP ; 

converting date string to date :- 
----------------------------------------

         date string   =>  '14-sep-23'
                                    '09/14/23'			   
  
               TO_DATE(date string,'format')

ex :- 

  SQL>SELECT  SYSDATE + 10 FROM DUAL ;   =>  24-SEP-23

  SQL>SELECT  '01-OCT-23' + 100 FROM DUAL ;  => ERROR

   num + num  => valid
   date + num  =>  valid
   string + num  => invalid
    
  SQL>SELECT  TO_DATE('01-OCT-23','DD-MON-YY') + 100 FROM DUAL ; 

     calculate  '09/13/23' + 50    ?

   SQL>SELECT  TO_DATE( '09/13/23', 'MM/DD/YY') + 50  FROM DUAL ;

 scenario :- 

 SQL>CREATE TABLE CUST
          (
           CID  NUMBER(2),
           CNAME VARCHAR2(10),
           DOB  DATE
          );

 SQL>INSERT INTO CUST VALUES(10,'A',TO_DATE('03/10/03','MM/DD/YY'));

 SQL>INSERT INTO CUST VALUES(&CID,'&CNAME',TO_DATE('&DATE','MM/DD/YY'));

 SQL> INSERT INTO CUST VALUES(12,'C','14-SEP-23 8:20:10'); => ERROR

 NOTE :- by default oracle allows date but to insert date & time use TO_DATE 
 function.

 SQL> INSERT INTO CUST VALUES(12,'C',
                                     TO_DATE('14-SEP-23 8:20:10','DD-MON-YY HH:MI:SS'));


	INPUT		OUTPUT		FUNCTION
	DD-MON-YY	MM/DD/YY	TO_CHAR
	MM/DD/YY	DD-MON-YY	TO_DATE
	oracle		other		TO_CHAR
	other		oracle		TO_DATE	

 => write a query to display on which day india got independence ?

   SELECT TO_CHAR(TO_DATE('15-AUG-1947','DD-MON-YYYY'),'DAY') 
   FROM DUAL;

  converting numeric string to number :- 
  -----------------------------------------------------

         numeric string  =>  '5000'    ,   '5,000'   ,  '$5,000' 
                                          
                         TO_NUMBER(numeric string,'format')

  SQL> SELECT  5000 + '1000'  FROM DUAL ;    => 6000

 SQL>SELECT 5000 + TO_NUMBER('1,000','9G999')  FROM DUAL ;  => 6000

  calculate   'USD5,000'  +   '$3,000'   ? 

 SQL>SELECT  TO_NUMBER('USD5,000','C9G999')  +
                           TO_NUMBER( '$3,000','L9G999')
          FROM DUAL ; 
  
	INPUT		OUTPUT		FUNCTION
	5000		$5,000		TO_CHAR
	$5,000		5000		TO_NUMBER			
 
15-sep-23

 Special functions :- 
 ------------------------

 NVL() :- 
 -----------

  => used to convert null values

                    NVL(arg1,arg2)

    if arg1 = null returns arg2
    if arg1 <> null returns arg1 only 

 ex :- 

   NVL(100,200)            =>   100
   NVL(NULL,200)         =>   200

 => display   ENAME  SAL   COMM   TOTSAL   ? 

                  TOTSAL = SAL + COMM 

   SELECT ENAME,SAL,COMM,SAL+COMM AS TOTSAL FROM EMP ; 

	smith	800	null	null	
	allen	1600	300	1900

   SELECT ENAME,SAL,COMM,SAL+NVL(COMM,0) AS TOTSAL FROM EMP ; 

	smith	800	null	800
	allen	1600	300	1900
	
   => display   ENAME	SAL	COMM ? 
        if comm = NULL display N/A  ?

       SELECT  ENAME,SAL,NVL(TO_CHAR(COMM),'N/A') AS COMM 
       FROM EMP ;   

 NVL2() :- 
 -------------

 => nvl2 converts both nulls and not nulls.

             NVL2(arg1,arg2,arg3) 
  
       if arg1 = null returns arg3
       if arg1 <> null returns arg2 

  ex :- 

   NVL2(100,200,300)           =>     200
   NVL2(NULL,200,300)        =>     300
   
 => update employee comm as follows ?

       if comm = null update with 500
                    <> null incr by 200 

     UPDATE EMP SET COMM = NVL2(COMM,COMM+200,500) ;

 how to implement if-then-else :- 
 -----------------------------------------

 1  DECODE function
 2  CASE  statement

 DECODE() :- 
 -----------------
 
DECODE(expr , value1,return expr1,
                           value2,return expr2,
                          ----------------------- ,
                          [default expr])

ex :- 

 => display   ENAME   JOB  ?

          IF JOB='CLERK'   DISPLAY WORKER
                        MANAGER             BOSS
                        PRESIDENT	       BIG BOSS
                        OTHERS                 EMPLOYEE

   SELECT ENAME,
                  DECODE(JOB,'CLERK','WORKER',
		          'MANAGER','BOSS',
                                          'PRESIDENT','BIG BOSS',
                                           'EMPLOYEE') AS JOB
  FROM EMP ;

  
=> increment employee salaries in table as follows ?

    if deptno =10  incr sal by10%
                    20                   15% 
                    30                   20%
                  others                5%
  
   UPDATE EMP
   SET SAL = DECODE(DEPTNO,10, SAL*1.1, 
                                                      20,SAL*1.15,
                                                      30,SAL*1.2,
                                                      SAL*1.05) ;
  
 CASE statement :- 
 ------------------------

 => used to implement IF-THEN-ELSE
 => similar to switch case.
 => used to return values based on conditions.
 => case statements are 2 types 

 1 simple case
 2 searched case 

 1 simple case :- 
 ---------------------

=> use simple case when conditions based on "=" operator.

 CASE expr
 WHEN value1 THEN return expr1
 WHEN value2 THEN return expr2
 ----------------------------
 ELSE return expr
 END

ex :- 

   SELECT ENAME,
                 CASE JOB
                 WHEN 'CLERK' THEN  'WORKER'
                 WHEN 'MANAGER' THEN 'BOSS'
                 WHEN 'PRESIDENT' THEN 'BIG BOSS'
                 ELSE 'EMPLOYEE' 
                 END AS JOB
  FROM EMP ;

16-sep-23

searched case :- 
-----------------------

 => use searched case when conditions not based on "=" operator.

    CASE
    WHEN COND1 THEN RETURN EXPR1
    WHEN COND2 THEN RETURN EXPR2
    -------------------  
    ELSE RETURN EXPR
    END

 ex :- 

   =>  display  ENAME    SAL	SALRANGE   ? 

      		if sal > 3000  display   Hisal
                                     sal < 3000  display   Losal
                                     sal = 3000   display  Avgsal

        SELECT ename,sal,
                        case 
                        when sal>3000 then 'Hisal'
                        when sal<3000 then 'Losal'
                        else  'Avgsal'
                        end as salrange
         FROM emp ; 

 => display   SNO	TOTAL	AVG	RESULT  ? 

   STUDENT
   SNO	SNAME	S1	S2	S3
   1	A	80	90	70
   2	B	30	60	50

  SELECT  SNO,
                  S1+S2+S3 AS TOTAL,
                  (S1+S2+S3)/3 AS AVG,
                  CASE 
                  WHEN S1>=35 AND S2>=35 AND S3>=35 THEN 'PASS'
                  ELSE 'FAIL'
                  END AS RESULT
  FROM STUDENT ;

=> difference between decode & case  ?

	 DECODE				CASE

 1 decode is a function			case is a statement

 2 supports only conditions			supports all conditions
    based on "=" operator			
 
 how to implement loop in sql :- 
 ---------------------------------------

 SELECT LEVEL                                 FOR(LEVEL=1;LEVEL<=10;LEVEL++)
 FROM DUAL                                         {
 CONNECT BY LEVEL <= 10;                     PRINT LEVEL ;
                                                                 }
=> "LEVEL" is  a system variable.
=> by default LEVEL initialized with 1.
=> by default LEVEL is incremented by 1.
 
=> write a query to print even numbers upto 20 ? 

     SELECT LEVEL
     FROM DUAL
     WHERE MOD(LEVEL,2)=0
     CONNECT BY LEVEL <= 20;

=>  write a query to print following pattern ?

        INPUT :-  NARESH

   OUTPUT :- 

    N
    A
    R
    E
    S
    H

     SELECT  SUBSTR('NARESH',LEVEL,1)
     FROM DUAL
     CONNECT BY  LEVEL <=  LENGTH('NARESH') ;

   => write a query to print following pattern ?

      INPUT :-  NARESH

      OUTPUT :- 

      N
      NA
      NAR
      NARE
      NARES
      NARESH

     SELECT  SUBSTR('NARESH',1,LEVEL)
     FROM DUAL
     CONNECT BY  LEVEL <=  LENGTH('NARESH') ;

=> write a query to print following pattern ?

  *
  **
  ***
  ****
  *****

  **********

  SELECT  RPAD('*',LEVEL,'*')
  FROM DUAL
  CONNECT BY LEVEL <= 10 ;

=>    
 
  SELECT  RPAD(' ',10-LEVEL,' ')||
                  RPAD('*',LEVEL,'*')||
                  RPAD('*',LEVEL-1,'*')
  FROM DUAL
  CONNECT BY LEVEL <= 10 ;

         *
        ***
       *****  
      *******

=> write a query to print 2024 calendar ?          
 
	01-JAN-2024	?
	02-JAN-2024	?

	31-DEC-2024	?

    SELECT   TO_DATE('31-DEC-2023','DD-MON-YYYY') + LEVEL  AS SDATE ,
                     TO_CHAR( TO_DATE('31-DEC-2023','DD-MON-YYYY') + LEVEL,'DAY') AS DAY
    FROM DUAL 
    CONNECT BY LEVEL <= 366 ;

 => Query to print sundays in 2024 calendar ?

     SELECT   
        TO_DATE('31-DEC-2023','DD-MON-YYYY') + LEVEL  AS SDATE ,
       TO_CHAR( TO_DATE('31-DEC-2023','DD-MON-YYYY') + LEVEL,'DAY') AS DAY
    FROM DUAL 
    WHERE  TO_CHAR( TO_DATE('31-DEC-2023','DD-MON-YYYY') + LEVEL,'fmDAY')='SUNDAY'
    CONNECT BY LEVEL <= 366 ;

19-sep-23 

 Analytical Functions :- 
 ------------------------------

 rank & dense_rank :- 
 -----------------------------  

  => both functions are used to find ranks 
  => ranking is based on some column
  => for rank functions data must be sorted
              
     syn :-   rank() over (order by colname asc/desc)
                 dense_rank() over (order by colname asc/desc)

   => display ranks of the employees based on sal  and highest paid employee
        should get 1st rank ?

        SELECT empno,ename,sal,
                       rank() over (order by sal desc) as rnk
        FROM emp ; 
 
        SELECT empno,ename,sal,
                      dense_rank() over (order by sal desc) as rnk
        FROM emp ; 

       difference between rank & dense_rank  ?

       1   rank function generates gaps but dense_rank will not generate gaps.

       2   in rank function ranks are always in sequence but in dense_rank 
            ranks may not be in sequence.
       
               	 SAL	RANK		DENSE_RANK
              	 5000	1		1		
	 4000	2		2
	 3000	3		3
                  3000	3		3
                  3000	3		3
                  2000	6		4
                  2000	6		4
                  1000	8		5
 
  => display ranks of the employees based on hiredate ,if hiredates are same then
        ranking should  be based on sal ?

       SELECT empno,ename,sal,hiredate,
                      dense_rank() over (order by hiredate asc,sal desc) as rnk
       FROM emp ;

    PARTITION BY clause :- 
    -------------------------------- 

    => partition by clause is used to divide the table based on one or more columns.

    => used to find ranks with in group , for ex to find ranks with in dept first
          we need to divide the table dept wise and apply  rank functions on each
          dept instead of applying it on whole table.

   ex :- 

          SQL>BREAK ON DEPTNO SKIP 1 ;

          SQL>SELECT deptno,empno,ename,sal,
                          dense_rank() over (partition by deptno order by sal desc) as rnk
                 FROM emp ;

        	10	5000	1
		2450	2
		1300	3

	20	3000	1
		3000	1
		2975	2

 ROW_NUMBER() :- 
-----------------------------

 => returns record numbers after sorting
 => it is also based on some column
 => data must be sorted

        row_number() over (order by colname asc/desc)

 ex :- 

      SELECT empno,ename,sal,
                      row_number() over (order by  sal desc)  as rno
      FROM emp; 

     SAL		RNK		DRNK		RNO
     5000		1		1		1
     4000		2		2		2
     3000		3		3		3
     3000		3		3		4
     3000		3		3		5
     2000		6		4		6
     2000		6		4		7
     1000		8		5		8

 multi-row / group / aggregate functions :- 
 -------------------------------------------------------

=> these functions process group of rows and returns one value.
 
  MAX
  MIN
  SUM
  AVG
  COUNT
  COUNT(*)

 MAX() :- 
 -------------

  => returns maximum value

                MAX(arg) 

     SQL>SELECT MAX(sal) FROM emp ;   => 5000

    SQL>SELECT MAX(hiredate) FROM emp ; => 12-jan-83

     SQL>SELECT MAX(ename) FROM emp ;  =>  ward 

MIN() :- 
----------
 
 => returns minimum value
 
                       MIN(arg) 

    SQL>SELECT MIN(sal) FROM emp ;   =>   800
  
20-sep-23

sum() :- 
-----------

  => returns total

     sum(arg) 

  SQL>SELECT SUM(sal) FROM emp ;  => 29025 

 => round the total sal to hundreds ?

  SQL>SELECT  ROUND(SUM(sal),-2)  FROM  emp;  => 29000

    29000------------------29050---------------------------29100
 
=> after rounding display totsal with thounsad seperator and currency symbol ?

     SELECT  TO_CHAR(ROUND(SUM(sal),-2) , 'L99G999')
     FROM  emp;

     output :-  $29,000

 => display total sal including comm ? 

     SELECT SUM(sal+comm) FROM emp ;   => 7800

    SAL	COMM	SAL+COMM
    5000	NULL	NULL
    3000	500	3500
    4000	NULL	NULL
 
    SUM(SAL) 	     =     12000
    SUM(SAL+COMM)   =      3500

   SELECT SUM(SAL+ NVL(COMM,0)) FROM emp ;  => 

    SAL	COMM	SAL+nvl(COMM,0)
    5000	NULL	5000
    3000	500	3500
    4000	NULL	4000

  SUM(SAL)   = 12000
  SUM(SAL+NVL(COMM,0))  =  12500

 => display total sal paid to managers ?

      SELECT SUM(sal) 
      FROM emp
      WHERE job='MANAGER' ;   => 8275

  AVG() :- 
  -----------

  =>  returns average value

             AVG(arg) 

   SELECT AVG(sal) FROM emp ;   =>  2073.21429

 => round total sal to lowest integer ? 

  SELECT FLOOR(AVG(sal)) FROM emp ;  => 2073

 note :- 

 => both sum,avg functions cannot be applied on char,date columns 

COUNT() :- 
----------------

 => returns no of values present in a column
 
             COUNT(arg) 

   SQL>SELECT COUNT(empno) FROM emp ;   =>  14

   SQL>SELECT COUNT(comm) FROM emp ;   => 4 => nulls are not counted

 COUNT(*) :- 
 ----------------

 => returns no of rows in a table.

 SQL>SELECT COUNT(*) FROM emp ;  =>  14 

T1
F1
10
NULL
20
NULL
30

         COUNT(F1)    =>    3
         COUNT(*)       =>    5

=> no of employees joined in 1981 year ?

    SELECT COUNT(*)
    FROM emp
    WHERE TO_CHAR(hiredate,'yyyy')=1981 ;  => 10

 => no of employees joined on sunday ?

   SELECT COUNT(*)
   FROM emp 
   WHERE TO_CHAR(hiredate,'fmday') = 'sunday'  ; 

 => no of employees joined in 2nd quarter of 1981 year ?
 
    SELECT COUNT(*)
   FROM emp 
   WHERE TO_CHAR(hiredate,'yyyy-q') = '1981-2' ;            

 NOTE :- 

 => group functions are not allowed in where clause and they are allowed
      in select,having clauses.

     SELECT ename
     FROM emp
     WHERE sal = MAX(sal) ;   => error

     SELECT deptno
     FROM emp
     WHERE count(*) = 3 ;   =>   error

 
summary :- 

string :- upper,lower,initcap,length,substr,instr,lpad,rpad,ltrim,rtrim,trim,
             replace,translate,reverse

numeric :-  abs,power,sqrt,sign,mod,round,trunc,ceil,floor

date    :-   add_months,months_betwee,last_day,next_day

conversion :-  to_char,to_date,to_number

special   :-   nvl,nvl2,decode

analytical :-   rank,dense_rank, row_number

group    :-   max,min,sum,avg,count,count(*)

21-SEP-23

GROUP BY clause :- 
-----------------------------

 => GROUP BY clause is used to group rows based on one or more columns to
       calculate min,max,sum,avg,count for each group.

      EMP
     EMPNO	ENAME	SAL	DEPTNO
     1		A	5000	10
     2		B	4000	20    GROUP BY		10     9000	
     3		C	6000	30 =================>	20     7000
     4		D	3000	20			30     6000
     5		E	4000	10

          detailed data					         summarized data
 
  
  => GROUP BY clause converts detailed data into summarized data which is useful
       for analysis.

 syntax :- 
 -------------

 SELECT columns
 FROM tabname
 [WHERE cond]
 GROUP BY col1,col2,----
 [HAVING cond]
 [ORDER BY col ASC/DESC,---] ;

execution :-
----------------

FROM
WHERE
GROUP BY
HAVING
SELECT
ORDER BY 

examples :- 

 =>  display dept wise total salaries ?
 
       SELECT  deptno,SUM(sal)
       FROM emp 
       GROUP BY deptno ; 

 FROM emp :-
 -------------------

     EMPNO	ENAME	SAL	DEPTNO
     1		A	5000	10
     2		B	4000	20   
     3		C	6000	30 
     4		D	3000	20		 
     5		E	4000	10

   GROUP BY deptno :-
  ------------------------------

 10
	1	A	5000
	5	E	4000

 20
	2	B	4000
	4	D	3000

 30
	3	C	6000

SELECT  deptno,SUM(sal) :-
---------------------------------------

10	9000
20	7000
30	6000

=> display job wise min sal,max sal,sum sal,no of emps ?

     SELECT job,MIN(sal),
                          MAX(sal),
                          SUM(sal),
                          COUNT(*)
     FROM emp
     GROUP BY job ;

 => display year wise no of employees joined ?

     SELECT  TO_CHAR(HIREDATE,'YYYY') AS YEAR,
                      COUNT(*) 
     FROM EMP
     GROUP BY TO_CHAR(HIREDATE,'YYYY') ;

=> display day wise no of employees joined ?

    SELECT  TO_CHAR(HIREDATE,'DAY') AS DAY,
                      COUNT(*) 
     FROM EMP
     GROUP BY TO_CHAR(HIREDATE,'DAY') ;

 => display no of employees joined month wise in the year 1981 ?

     
    SELECT  TO_CHAR(HIREDATE,'month') AS month,
                      COUNT(*) 
     FROM EMP
     WHERE  TO_CHAR(HIREDATE,'YYYY')=1981
     GROUP BY TO_CHAR(HIREDATE,'month') ;
  
=> find the departments having more than 3 employees ?

    SELECT deptno,COUNT(*)
    FROM emp 
    WHERE COUNT(*) > 3
    GROUP BY deptno ;             => ERROR
 
    above query returns error because oracle cannot calculate dept wise count
    before group by and it can calculate only after group by , so apply the
    condition COUNT(*) > 3  after group by using HAVING clause.

    SELECT deptno,COUNT(*)
    FROM emp 
    GROUP BY deptno 
    HAVING COUNT(*) > 3 ; 

   22-SEP-23

  WHERE VS HAVING :- 
 ---------------------------------
   
          WHERE				HAVING

1    used to select specific rows		used to select specific groups

2    conditions applied before                                     conditions applied after group by 
       group by


3   use where clause if			use having clause
     cond doesn't contain			if cond contains
     group function				group function

  =>  display job wise no of employees where job = clerk,manager and no of emps > 3 ?
 
    SELECT job,COUNT(*)
    FROM emp 
    WHERE  job IN ('CLERK','MANAGER')
    GROUP BY job 
    HAVING    COUNT(*) > 3 ;
 
 =>  find the southern states having more than 5cr population ?

     PERSONS
     AADHARNO    NAME      GENDER     AGE     ADDR    CITY    STATE
    
     SELECT  STATE,COUNT(*)
     FROM PERSONS
     WHERE STATE IN ('AP','TS','TN','KA','KL')
     GROUP BY STATE 
      HAVING COUNT(*) > 50000000 ;
   
=> display dept wise and with in dept job wise total sal ?

     SQL>BREAK ON DEPTNO SKIP 1

      SQL>SELECT DEPTNO,JOB,SUM(SAL)
      FROM EMP
      GROUP BY DEPTNO,JOB 
      ORDER BY DEPTNO ASC ; 
      
    
 10	CLERK		1300
	MANAGER	2450
	PRESIDENT	5000

 20	ANALYST		6000
	CLERK		1900
	MANAGER	2975

 30	CLERK		950
	MANAGER	2850
	SALESMAN	5600


=>  display state wise and with in state gender wise population ?   

     PERSONS
     AADHARNO    NAME      GENDER     AGE     ADDR    CITY    STATE

=>  display last 5 years  year wise and with in year quarter wise total amount ?

    SALES
    DATEID	PRODID	  CUSTID	  QTY	AMT
    21-SEP-23	100	  10	  1	2000

   2019	1	?
	2	?
	3	?
	4	?

  2020	1	?
	2	?
	3	?
	4	?

ROLLUP & CUBE :- 
-----------------------------

 => both functions are used to display subtotals and grand total

        syn :-    GROUP BY  ROLLUP(COL1,COL2,----)
                     GROUP BY  CUBE(COL1,COL2,-----)

 ROLLUP :- 
------------------

 => ROLLUP displays subtotals for each group and also displays grand total

      SELECT DEPTNO,JOB,SUM(SAL)
      FROM EMP
      GROUP BY ROLLUP(DEPTNO,JOB)
      ORDER BY DEPTNO ASC ; 

10	CLERK		1300
	MANAGER	2450
	PRESIDENT	5000
			8750	=> dept subtotal

 20	ANALYST		6000
	CLERK		1900
	MANAGER	2975				
			10875   =>  dept subtotal


              		                29025    => grand total

CUBE :- 
-----------

 => cube displays subtotals for each group by column (deptno,job)

      SELECT DEPTNO,JOB,SUM(SAL)
      FROM EMP
      GROUP BY CUBE(DEPTNO,JOB)
      ORDER BY DEPTNO ASC ; 

.  
10	CLERK		1300
	MANAGER	2450
	PRESIDENT	5000
			8750	=> dept subtotal

 20	ANALYST		6000
	CLERK		1900
	MANAGER	2975				
			10875   =>  dept subtotal

	ANALYST		6000     =>  job subtotal	
	CLERK		4150     =>  job subtotal
	SALESMAN	5600     =>  job subtotal

			29025  => grand total


23-SEP-23

GROUPING_ID() :- 
----------------------------

 => grouping_id function accepts group by columns and returns subtotal belongs to which 
      group by column.

      ex :-   GROUPING_ID(DEPTNO,JOB)

	1	=> subtotal belongs to 1st group by col i.e. deptno
	2	=> subtotal belongs to 2nd group by col i.e. job
	3	=> grand total

      SELECT DEPTNO,JOB,SUM(SAL) AS TOTSAL,
                     CASE GROUPING_ID(DEPTNO,JOB)  
                     WHEN 1 THEN  'Dept Subtotal'
                     WHEN 2 THEN 'Job subtotal'
                     WHEN 3 THEN 'Grand total'
                     END AS SUBTOTAL
      FROM EMP
      GROUP BY CUBE(DEPTNO,JOB)
      ORDER BY DEPTNO ASC ; 

     Question 1 :- 
     ----------------

     EMP44
     ENO	ENAME	SAL
     1	A	5000
     2	B	6000
     3	C	7000
     1	A	5000
     2	B	6000

    
=> display duplicate records ? 

   SELECT ENO,ENAME,SAL
   FROM EMP44
   GROUP BY ENO,ENAME,SAL
   HAVING COUNT(*) > 1 ; 

 
Question 2 :- 
-----------------
  
     SELECT DEPTNO,ENAME,COUNT(*)
     FROM EMP
     GROUP BY DEPTNO ;  => ERROR

    
  => in select only group by column and group functions are allowed  , other than these if any
       column appears then select stmt returns error

   Question 3 :- 
   ---------------------

    SELECT TO_CHAR(HIREDATE,'YYYY') AS YEAR,COUNT(*)
    FROM EMP
    GROUP BY YEAR    /* INVALID */
    ORDER BY YEAR ASC   /* VALID */   ;

   1  alias cannot be used in group by clause because group by clause is executed before select

   2  alias can be used in order by clause because order by clause is executed after select

  Range grouping :- 
  -------------------------- 
 
   SELECT CASE
                  WHEN SAL BETWEEN 0 AND 2000 THEN '0-2000'
                  WHEN SAL BETWEEN 2001 AND 4000 THEN '2001-4000'
                  WHEN SAL>4000 THEN ' ABOVE 4000'
                  END AS SALRANGE , COUNT(*) AS CNT
   FROM EMP 
   GROUP BY   CASE
                  WHEN SAL BETWEEN 0 AND 2000 THEN '0-2000'
                  WHEN SAL BETWEEN 2001 AND 4000 THEN '2001-4000'
                  WHEN SAL>4000 THEN ' ABOVE 4000'
                  END ;
 
  SUMMARY :- 

  1  importance of group by
  2  writing queries using group by
  3  where vs having 
  4  rollup & cube
  5  grouping_id

=========================================================================

25-SEP-23

			INTEGRITY CONSTRAINTS
			----------------------------------------

 
  => Integrity Constraints are rules to maintain data integrity i.e. data quality or data consistency
  => used to prevent users from entering invalid data.
  => used to enforce rules like min bal must be 1000
 => different integrity constraints in oracle 

  1  NOT NULL
  2  UNIQUE
  3  PRIMARY KEY
  4  CHECK
  5  FOREIGN KEY
  6  DEFAULT

=> constraints can be declared in two ways 

 1 column level
 2 table level

column level :-
--------------------

=> if constraints are declared immediately after declaring column then it is called column level

    CREATE TABLE <tabname>
    (
       colname datatype(size)   constraint,
       colname datatype(size)   constraint,
       ------------------------
    );

NOT NULL :-
------------------

 => NOT NULL constraint doesn't accept null values
 => a field declared with not null is called mandatory field

 ex :- 

  CREATE TABLE emp11
  (
    empno  NUMBER(4),
    ename  VARCHAR2(10) NOT NULL
  );

INSERT INTO emp11 VALUES(100,''); => ERROR
INSERT INTO emp11 VALUES(101,'ABC');

UNIQUE :- 
--------------

=> unique constraint doesn't accept duplicates
 
ex :- 

 CREATE TABLE cust
 (
   CID   	NUMBER(2),
   CNAME VARCHAR2(10) NOT NULL,
   EMAILID  VARCHAR2(30) UNIQUE
 );

 INSERT INTO CUST VALUES(10,'A','abc@gmail.com');
 INSERT INTO CUST VALUES(11,'B','abc@gmail.com');  => ERROR
 INSERT INTO CUST VALUES(12,'C','');
 INSERT INTO CUST VALUES(13,'D','');

 NOTE :- 	unique constraint allows nulls 

PRIMARY KEY :- 
------------------------

=> primary key constraint doesn't accept duplicates and nulls.
=> primary key is the combination of unique & not null.
=> in tables one column must be there to uniquely identify the records and into that
      column duplicates and nulls are not allowed , so declare that column as primary key.

 ex :- 

 CREATE TABLE EMP12
 (
    EMPID   NUMBER(4)  PRIMARY KEY,
    ENAME  VARCHAR2(10) NOT NULL
 );

INSERT INTO EMP12 VALUES(100,'A');
INSERT INTO EMP12 VALUES(100,'B');  => ERROR
INSERT INTO EMP12 VALUES(NULL,'C'); => ERROR

=> because it's not allowing duplicates & nulls into empid , so using empid we can
      uniquely identify the employees.

NOTE :- 

 => only one primary key is allowed per table , if we want multiple primary keys then
      declare one column with primary key and other columns with unique not null.

  CREATE TABLE CUST
  (
   CUSTID    NUMBER(6) PRIMARY KEY,
   CNAME    VARCHAR2(10) NOT NULL,
   AADHARNO  NUMBER(12) UNIQUE  NOT NULL
   PANNO          CHAR(10) UNIQUE NOT NULL
 );

=> difference between unique & primary key  ?

      	 UNIQUE			PRIMARY KEY

1	allows nulls		doesn't allow nulls

2	multiple columns		single column can be 
                  can be declared		declared with primary key
                  with unique 

candidate key :-
---------------------

=> a field eligible for primary key is called candidate key

 ex :- 

     VEHICLES
     VEHNO   VNAME    PRICE    MODEL     CHASSISNO

      candidate keys :-  VEHNO,CHASSISNO

      primary key  :-    VEHNO

      secondary key  :-  CHASSISNO
      or
      alternate key 

  => when primary key value is not available then we can access data by using secondary
        key. 

  => while creating table secondary key columns are declared with UNIQUE & NOT NULL

  CHECK :- 
  --------------

  => use check constraint when rule based on condition.

       syn :-   CHECK(condition)

 ex 1 :-  sal  must be min 3000

  CREATE TABLE emp13
  (
   empno NUMBER(4) PRIMARY KEY,
   ename VARCHAR2(10) NOT NULL,
   sal   NUMBER(7,2) CHECK(sal>=3000)
 );

 INSERT INTO emp13 VALUES(100,'A',1000); => ERROR
 INSERT INTO emp13 VALUES(101,'B',5000);
 INSERT INTO emp13 VALUES(102,'C',NULL);
   
 NOTE :- check constraint allows nulls

ex 2 :- gender must be 'm','f' ?

         gender   char(1)  CHECK(gender IN ('m','f'))

 26-sep-23

 ex 3 :-  amt   must be multiple of 100 ?
 
         amt  NUMBER(5)  CHECK(MOD(amt,100)=0)

ex 4 :-  pwd must be min 6 chars ?

        pwd   VARCHAR2(12)  CHECK(LENGTH(pwd) >= 6)

ex 5 :-  emailid must contain '@'
                         must end with '.com'  or  '.co'  or  '.in'  ?

           emailid  VARCHAR2(20) CHECK(emailid LIKE '%@%'
                                                                   AND
                                                                   (
                                                                    emailid LIKE '%.com'
                                                                    OR
                                                                    emailid LIKE '%.co'
                                                                    OR
                                                                    emailid LIKE '%.in'
                                                                    ))

  Foreign Key :- 
 ---------------------

  => Foreign key is used to establish relationship between two tables.

  => to establish relationship between two tables ,  take primary key of one table
       and add it to another table as foreign key and declare with references constraint.

ex :- 

 DEPT 
 DNO	DNAME	LOC
 10	HR	HYD
 20	IT	BLR

EMP
EMPNO	ENAME	SAL	DNO   REFERENCES   DEPT(DNO)
1	A	5000	 10
2	B	6000	 20
3	C	4000	 90 => NOT ACCEPTED
4	D	3000	10
5	E	4000	 NULL
 
=> values entered in fk column should match with values entered in pk column.
=> fk allows duplicates and nulls.
=> after declaring fk a relationship is established between two tables called parent/child
     relationship.
=> pk table is parent and fk table is child.

example :- 

 CREATE TABLE DEPT55
 (
  DNO  NUMBER(2)  PRIMARY KEY,
  DNAME VARCHAR2(10)   UNIQUE NOT NULL,
  LOC       VARCHAR2(10)
 );

 INSERT INTO DEPT55 VALUES(10,'HR','HYD');
 INSERT INTO DEPT55 VALUES(20,'IT','BLR');
  
 CREATE TABLE EMP55
 (
   EMPNO  NUMBER(4)  PRIMARY KEY,
   ENAME  VARCHAR2(10) NOT NULL,
   SAL         NUMBER(7)   CHECK(SAL>=3000),
   DNO       NUMBER(2)    REFERENCES DEPT55(DNO)
 );

INSERT INTO EMP55 VALUES(1,'A',5000,10);
INSERT INTO EMP55 VALUES(2,'B',6000,90); => ERROR
INSERT INTO EMP55 VALUES(3,'C',4000,10);
INSERT INTO EMP55 VALUES(4,'D',3000,NULL);

Assignment :- 

ACCOUNTS
ACCNO	ACTYPE	BAL

Rules :- 
-----------

 1 accno should not be duplicate & null
 2 actype must be 's' or 'c'
 3 bal must be min 1000


TRANSACTIONS
TRID	TTYPE	TDATE	TAMT	ACCNO

Rules :- 
-----------

 1  trid should not be duplicate & null
 2  ttype must be 'w' or 'd'
 3  tamt must be multiple of 100
 4  accno should match with accounts table accno
 5  accno should not be null

27-SEP-23

 Relationship Types :- 
 ----------------------------

 1  one to one (1:1)
 2  one to many (1:m)
 3 many to one  (m:1)
 4 many to many  (m:n)

 => default relationship in oracle is one to many (1:m)

 one to one relationship :- 
 -----------------------------------

  => to establish one to one relationship between two tables then declare fk with unique
       constraint.

   ex :- 

    DEPT
    DNO	DNAME 	   
    10	HR
     20	IT

    MGR
    MGRNO	MNAME		DNO   REFERENCES DEPT(DNO)  UNIQUE
    1		A		10
    2		B		20
   
 => in the above example relationship between dept & mgr is one to one because
      one dept is managed by one mgr and one mgr manages one dept.
  
 many to many relationship :- 
 --------------------------------------

 
ex :- 

     COURSE			STUDENT
     CID	CNAME			SID	SNAME	
     10	JAVA			1	A
     11	ORACLE			2	B

     REGISTRATIONS
     SID	CID	DOR	FEE
     1	10	?	2000
     1	11	?	?
     2	10	?	?

  => in the above example  one student can register for many courses and one course
       can be taken by many students , so relationship between student & course is many to many

   => to establish many to many relationship  , create third table and in the third table
         take primary keys of  both tables as foreign keys

  CREATE TABLE COURSE
  (
  CID  NUMBER(2) PRIMARY KEY,
  CNAME VARCHAR2(10) NOT NULL
  );

   INSERT INTO COURSE VALUES(10,'JAVA');
   INSERT INTO COURSE VALUES(11,'ORACLE');

  CREATE TABLE STUDENT
  (
   SID NUMBER(2) PRIMARY KEY,
   SNAME VARCHAR2(10)
  );

  INSERT INTO STUDENT VALUES(1,'A');
  INSERT INTO STUDENT VALUES(2,'B');

 CREATE TABLE REGISTRATIONS
 (
   SID NUMBER(2)  REFERENCES STUDENT(SID),
   CID NUMBER(2)  REFERENCES COURSE(CID),
   DOR DATE ,
   FEE NUMBER(5)
 );
 
INSERT INTO REGISTRATIONS(1,10,SYSDATE,2000);
INSERT INTO REGISTRATIONS(1,11,SYSDATE,2000);
INSERT INTO REGISTRATIONS(2,10,SYSDATE,2000);


  ER MODEL			RELATIONAL MODEL


 Entity				Tables

 Attributes				Fields

Relationship			Foreign key


BANK
CCODE	NAME	ADDR
-----------

BRANCH
BRANCH_ID	NAME	ADDR	CCODE (FK)
------------------

ACCOUNTS
ACCNO	ACTYPE	BAL	BRANCH_ID(FK)	CUSTID(FK)
-----------

LOANS
LOAN_ID	       LOAN_TYPE	AMT	BRANCH_ID(FK)	CUSTID(FK)
--------------


CUSTOMER
CUSTID	NAME	PHONE	ADDR
------------

DEFAULT :- 
-----------------

 => a column can be declared with default value as follows 

   ex :-    hiredate  date  default sysdate

 => while inserting if we skip hiredate then oracle inserts sysdate.

  ex :- 

   CREATE TABLE emp44
   (
     empno NUMBER(4) PRIMARY KEY,
     ename VARCHAR2(10) NOT NULL,
     hiredate DATE DEFAULT SYSDATE
   );

  INSERT INTO emp44(empno,ename) VALUES(100,'A');
  INSERT INTO emp44  VALUES(101,'B','01-JAN-23');
  INSERT INTO emp44  VALUES(102,'C','');

  SELECT * FROM emp44; 

  EMPNO	ENAME	HIREDATE
  100	A	27-SEP-23
  101	B	01-JAN-23
  102	C	NULL
 

28-SEP-23 

 Table level :- 
 ----------------

 => table level constraints are declared after declaring all columns
 => use  table level to declare constraints for multiple or combination of columns

  syn :- 

   create table <tabname>
   (
     colname datatype(size),
     colname datatype(size),
         constraint(col1,col2,---)
   );

 Declaring check constraint at table level :- 
 -------------------------------------------------------

 products
 prodid   pname   price    mfd_dt   	 exp_dt
 100       A           50        27-SEP-23	 01-JAN-23   => INVALID

        Rule :- exp_dt  > mfd_dt

 CREATE TABLE products
 (
   prodid NUMBER(3) PRIMARY KEY,
   pname VARCHAR2(10) NOT NULL,
   mfd_dt  DATE,
   exp_dt DATE,
         CHECK(exp_dt > mfd_dt)
 );

INSERT INTO products VALUES(100,'A',SYSDATE,'01-JAN-23'); => ERROR
INSERT INTO products VALUES(100,'A', '01-JAN-23',SYSDATE);

composite primary key :- 
--------------------------------

=> if combination of columns declared primary key then it is called composite primary key.

=> some tables we cannot uniquely identify the records by using single
     column and we need combination of columns to uniquely identify
     and  that combination must be declared primary key at table level.

 ex :-
     
    COURSE			STUDENT
     CID	CNAME			SID	SNAME	
     10	JAVA			1	A
     11	ORACLE			2	B

     REGISTRATIONS
     SID	CID	DOR	FEE
     1	10	?	2000
     1	11	?	?
     2	10	?	?

    create table course
    (
    cid  number(2) primary key,
    cname varchar2(10) not null
    );

   insert into course values(10,'java');
   insert into course values(11,'oracle'); 

   create table student
   (
    sid  number(2) primary key,
    sname varchar2(10) not null
   );

  insert into student values(1,'A');
  insert into student values(2,'B');

  create table registrations
  (
   sid  number(2) references student(sid),
   cid  number(2) references course(cid),
   dor date,
   fee number(5),
      primary key(sid,cid)
  );

insert into registrations values(1,10,sysdate,2000);
insert into registrations values(1,11,sysdate,2000);
insert into registrations values(2,10,sysdate,2000);
insert into registrations values(1,10,sysdate,2000); => error

ex 2 :- 

  SALES
  DATEID	 	PRODID	  CUSTID	  QTY   AMT
  27-SEP-23 	100	  10	  1        1000 
  27-SEP-23	101	  10	  1        500
  27-SEP-23             100             11            1        1000
  28-SEP-23             100             10            1        1000

 identity primary key & write create table script ? 

composite foreign key :-
--------------------------------

=> if combination of columns declared foreign key then it is called
     composite foreign key.

=> a composite foreign key refers composite prirmary key

ex :- 

     REGISTRATIONS
     SID	CID	DOR	FEE
     1	10	?	2000
     1	11	?	?
     2	10	?	?

     CERTIFICATES
     CERTNO     DOI	   SID	CID
     1000            ??	   1	10
     1001	         ??      1           11
     1002            ??      2           11  => invalid

 => in the above example sid,cid combination should match with registrations
      table sid,cid combination , so declare this combination as foreign key
      at table level.

     create table certificates
     (
         certno  NUMBER(4) PRIMARY KEY,
         doi      DATE,
         sid      NUMBER(2) ,
         cid      NUMBER(2) ,
                  FOREIGN KEY(sid,cid)  
                           REFERENCES registrations(sid,cid)) ;

  which of the following constraint cannot be declared at table level ?

  A  UNIQUE
  B  CHECK
  C  NOT NULL
  D  PRIMARY KEY
  E  FOREIGN KEY 
 
   ANS :- C

  Which statements are true regarding constraints ?

A  a foreign key cannot contain NULL value  F
B  a column with UNIQUE constraint can contain NULL value  T
C  a constraint is enforced only for the INSERT operation on a table F
D all constraints can be defined at column level and table level. F

29-SEP-23

 Adding constraints to existing table :- 
 -------------------------------------------------

 => "ALTER" command is used to add constraints to existing table.

 ex :- 

 CREATE TABLE emp22
 (
   empno NUMBER(4),
   ename VARCHAR2(10) ,
   sal     NUMBER(7),
   dno    NUMBER(2)
 );

Adding primary key :- 
-----------------------------

 => add primary key to empno ?  

      ALTER TABLE emp22
           ADD PRIMARY KEY(empno) ; 

 Adding check constraint :- 
 ------------------------------------

 => add check constraint with cond sal>=3000 ?

     ALTER TABLE emp22
            ADD CHECK(sal>=3000);

  
    ALTER TABLE emp 
         ADD CHECK(sal>=3000) ;  => ERROR

 NOTE :- 

  => while adding constraint oracle also validates existing data  , if existing
        data doesn't satisfy the cond then constraint cannot be added.

 NOVALIDATE :- 
 ----------------------

 =>  if check constraint added with NOVALIDATE then oracle will not validates
       existing data,  it validates  only new data.

     ALTER TABLE emp 
         ADD CHECK(sal>=3000)  NOVALIDATE ; 

 Adding foreign key :- 
 ----------------------------

  =>  add fk to dno  that refers dept table primary key i.e. deptno ?

      ALTER TABLE emp22
           ADD FOREIGN KEY (dno)  REFERENCES dept(deptno) ; 

 Changing from NULL to NOT NULL :- 
 --------------------------------------------------

  => modify the column ename to NOT NULL ?

    ALTER TABLE emp22
          MODIFY (ename NOT NULL) ;

USER_CONSTRAINTS :- 
-----------------------------------

=> It is a system table that stores information about constraints declared in a table

 SQL>SET PAGESIZE 1000
 SQL>COLUMN constraint_name FORMAT A20
 SQL>COLUMN search_condition FORMAT A30
 SQL>SELECT constraint_name,constraint_type,
                search_condition
 FROM user_constraints 
 WHERE table_name='EMP22' ; 

CONSTRAINT_NAME      	C 	SEARCH_CONDITION
-------------------- 	        	- 	------------------------------
SYS_C008568         		R
SYS_C008566          	C 	sal>=3000
SYS_C008569          	C 	"ENAME" IS NOT NULL
SYS_C008565          	P

Droping constraints :- 
--------------------------

   ALTER TABLE <tabname>
           DROP CONSTRAINT <name> ;

 => drop check constraint in emp22 table ? 

  ALTER TABLE emp22
        DROP CONSTRAINT SYS_C008566 ; 

=> drop primary key in dept table ? 

   ALTER TABLE dept 
        DROP PRIMARY KEY ;   => ERROR

   DROP TABLE dept ;             => ERROR

 NOTE :- 

  => primary key cannot be dropped if referenced by some fk.
  => primary key table cannot be dropped if referenced by some fk.

CASCADE option :- 
-----------------------

  ALTER TABLE dept 
        DROP PRIMARY KEY  CASCADE ;  => drops  pk with dependent fk

  DROP TABLE dept  CASCADE CONSTRAINTS ;  => drops table with dependent fk

30-sep-23

 DELETE rules :- 
 ----------------------

 1  ON DELETE NO ACTION (DEFAULT)
 2  ON DELETE CASCADE
 3  ON DELETE SET NULL 
 
=> these rules are declared with foreign key
=> delete rules specifies how child rows are affected if parent row is deleted 

on delete no action :- 
----------------------------

 => parent row cannot be deleted if associated with child rows.

create table dept77
(
  dno number(2) primary key,
  dname varchar2(10) unique not null
 );

insert into dept77 values(10,'HR');
insert into dept77 values(20,'IT');

create table emp77
(
  empno number(4) primary key,
  ename varchar2(10) not null,
  dno      number(2) references dept77(dno)
 );

insert into emp77 values(1,'A',10);
insert into emp77 values(2,'B',10);

DELETE FROM DEPT77 WHERE DNO=10;  => ERROR

scenario :-
-------------

 ACCOUNTS
 ACCNO	ACTYPE	BAL
 100	S	10000

 LOANS
 LOANID	 TYPE	AMT	ACCNO  references accounts(accno)
 111	 H	30	100
 112	 C	10	100

 NOTE :- account closing is not possible if associated with loans

ON DELETE CASCADE :- 
-----------------------------------

=> if parent row is deleted then it is deleted along with child rows.

 create table dept77
(
  dno number(2) primary key,
  dname varchar2(10) unique not null
 );

insert into dept77 values(10,'HR');
insert into dept77 values(20,'IT');

create table emp77
(
  empno number(4) primary key,
  ename varchar2(10) not null,
  dno      number(2) references dept77(dno)  ON DELETE CASCADE
 );

insert into emp77 values(1,'A',10);
insert into emp77 values(2,'B',10);

DELETE FROM DEPT77 WHERE DNO=10;  => 1 row deleted

SELECT * FROM EMP77 ;  => no rows 

scenario :- 
--------------

 ACCOUNTS
 ACCNO	ACTYPE	BAL
 100	S	10000

 TRANSACTIONS
 TRID	TTYPE	TDATE	TAMT	ACCNO   REFERENCES ACCOUNTS(ACCNO)
 1	W	??	2000	100          ON DELETE CASCADE
 2	D	?	1000	100

NOTE :-  if accounts is closed then along with account delete transactions.

 ON DELETE SET NULL :-
 ----------------------------------

 => if parent row is deleted but child rows are not deleted but fk will be set to null

 create table dept77
(
  dno number(2) primary key,
  dname varchar2(10) unique not null
 );

insert into dept77 values(10,'HR');
insert into dept77 values(20,'IT');

create table emp77
(
  empno number(4) primary key,
  ename varchar2(10) not null,
  dno      number(2) references dept77(dno)  ON DELETE SET NULL
 );

insert into emp77 values(1,'A',10);
insert into emp77 values(2,'B',10);

DELETE FROM DEPT77 WHERE DNO=10; => 1 row deleted

SELECT * FROM EMP77;

     EMPNO 	ENAME             	DNO
---------- 		---------- 		----------
         1 		A
         2 		B

scenario :-
--------------

projects
projid	pname	duration	cost	client
 100	A	5	500	TATA MOTORS
101	B	3	300	DBS BANK
102	C	4	600	L&T 

emp
empid	ename	projid  REFERENCES projects(projid)
1	K	100    ON DELETE SET NULL
2	D	101

NOTE :- if project is completed (deleted) , set the employee projid to null

summary :-

 => importance of constraints 
 => types of constraints 
 => declaring constraints
           column level
           table level 
 => adding constraints to existing table
 => droping constraints
 => getting constraints information

Which CREATE TABLE statement is valid?

A. CREATE TABLE ord_details
(ord_no NUMBER(2) PRIMARY KEY,
item_no NUMBER(3) PRIMARY KEY,
ord_date DATE NOT NULL);

B. CREATE TABLE ord_details
(ord_no NUMBER(2) UNIQUE, NOT NULL,
item_no NUMBER(3),
ord_date DATE DEFAULT SYSDATE NOT NULL);

C. CREATE TABLE ord_details
(ord_no NUMBER(2) ,
item_no NUMBER(3),
ord_date DATE DEFAULT NOT NULL,
CONSTRAINT ord_uq UNIQUE (ord_no),
CONSTRAINT ord_pk PRIMARY KEY (ord_no));

D. CREATE TABLE ord_details
(ord_no NUMBER(2),
item_no NUMBER(3),
ord_date DATE DEFAULT SYSDATE NOT NULL,
CONSTRAINT ord_pk PRIMARY KEY (ord_no, item_no));

ANS :-  D

  Evaluate the following CREATE TABLE commands:

CREATE TABLE orders
(ord_no NUMBER(2) CONSTRAINT ord_pk PRIMARY KEY,
ord_date DATE,
cust_id NUMBER(4));

CREATE TABLE ord_items
(ord_no NUMBER(2),
item_no NUMBER(3),
qty NUMBER(3) CHECK (qty BETWEEN 100 AND 200),
expiry_date date CHECK (expiry_date > SYSDATE),
CONSTRAINT it_pk PRIMARY KEY (ord_no,item_no),
CONSTRAINT ord_fk FOREIGN KEY(ord_no) REFERENCES orders(ord_no));

The above command fails when executed. What could be the reason?

A. SYSDATE cannot be used with the CHECK constraint.
B. The BETWEEN clause cannot be used for the CHECK constraint.
C. The CHECK constraint cannot be placed on columns having the DATE data type.
D. ORD_NO and ITEM_NO cannot be used as a composite primary key 
  because ORD_NO is also the FOREIGN KEY.

ANS :-  A 

==================================================================

02-OCT-23		JOINS
			---------

 => join is an operation performed to display data from two or more tables.

 => in db related data stored in multiple tables , if we want to combine or merge
      data data stored in multiple tables we need to join those tables.

 ex :- 

   orders					cust			
   ordid   orddt   deldt    cid			cid	cname	caddr
   1000   ?        ?          10			10	A	HYD
   1001   ?        ?          11			11	B	HYD
   1002   ?        ?          12			12	C	HYD


 output :-

   ordid	orddt	deldt	cname	caddr
   1000	?	?	A	HYD

 Types of joins :- 
 -----------------------

 1 equi join / inner join
 2 outer join
        left outer
        right outer
        full outer
 3 non equi join
 4 self join
 5 cross join / cartesian join

Equi / Inner join :- 
-------------------------

 =>  To perform equi join  between the two tables there must be a common field and
        name of the common field need not to be same and pk-fk relationship is not
        compulsory.

 => we can write join queries in 2 styles 

  1  Native style (oracle style)
  2  ANSI style        

Native style :- 
-----------------

 SELECT columns
 FROM  tab1,tab2
 WHERE join condition ;

 join condition :- 
 ---------------------

 => based  on the given join condition oracle joins the records of two tables.

 => join condition determines which record of 1st table joined with which record of 2nd table

           table1.commonfield  =  table2.commonfield

 ex :- 

  EMP					DEPT
  EMPNO  ENAME  SAL  DEPTNO		DEPTNO	DNAME		LOC
  1              A             3000 10			10	ACCOUNTS		
  2              B             4000 20			20	RESEARCH
  3              C            5000 30			30	SALES
  4              D            3000 10			40	OPERATIONS
  5              E            2000 NULL

=> display    ENAME	   DNAME    ? 
 
     SELECT  ENAME,DNAME
     FROM  EMP ,DEPT 
    WHERE EMP.DEPTNO = DEPT.DEPTNO;

      A	ACCOUNTS
     B	RESEARCH
     C	SALES
     D	ACCOUNTS

 NOTE :- 

 => in join queries declare table alias and prefix column names with table alias for two reasons

   1  to avoid ambiguity
   2  for faster execution 

    SELECT E.ENAME,D.DEPTNO,D.DNAME,D.LOC AS CITY
    FROM EMP E,DEPT  D
    WHERE E.DEPTNO = D.DEPTNO ;
 
  =>  display  ENAME   DNAME working at NEW YORK loc ?

          SELECT E.ENAME,D.DNAME
          FROM  EMP E , DEPT D
         WHERE  E.DEPTNO = D.DEPTNO      /* join cond */
                          AND
                         D.LOC='NEW YORK'     /*  filter cond */ ;


 => display order details with customer details ?

     SELECT  O.* , C.*
     FROM  ORDERS O ,CUST C
     WHERE O.CID = C.CID ; 

 => display order details with cust details to be delivered today ?

      SELECT  O.* , C.*
      FROM  ORDERS O ,CUST C
      WHERE O.CID = C.CID 
                      AND
                      O.DELDT = SYSDATE ; 

 03-oct-23

 Joining more than 2 tables :- 
 --------------------------------------

 =>  if no of tables increases  no of join conditions also increases , To join
       N tables N-1 join conditions required.

      SELECT columns
      FROM tab1,tab2,tab3,---
      WHERE join cond1
                    AND
                    join cond2
                    AND
                    ------    ;

  ex :- 
 
   EMP		DEPT		LOCATIONS	COUNTRIES
   empno		deptno		locid		country_id
   ename		dname		city		country_name
   sal		locid		state
   deptno				country_id

 => display  ENAME	  DNAME	  CITY	STATE	COUNTRY  ?
                   ---------    -----------    ---------------------          ----------------
                    EMP      DEPT         LOCATIONS            COUNTRIES

        SELECT   E.ENAME,
                        D.DNAME,
                        L.CITY,L.STATE,
                        C.COUNTRY_NAME 
       FROM      EMP E,
                       DEPT D,
                       LOCATIONS L,
                       COUNTRIES C
        WHERE  E.DEPTNO = D.DEPTNO
                       AND
                      D.LOCID  = L.LOCID
                      AND
                      L.COUNTRY_ID = C.COUNTRY_ID ;

ANSI style :- 
------------------

 => ANSI style is introduced in oracle 9i
 => Adv of ANSI style is portability 
 => Native style doesn't gurantees portability but ANSI style gurantees portability
 => ANSI style queries can be migrated from one db to another db without making changes
 => in ANSI style tablenames are seperated by keywords
 => use ON clause for join conditions instead of WHERE clause.

   SELECT columns
   FROM tab1  INNER JOIN tab2
        ON  join condition ; 

 ex :- 

 => display  ENAME    DNAME    ?

    SELECT E.ENAME,D.DNAME
      FROM  EMP E INNER JOIN DEPT D
           ON   E.DEPTNO = D.DEPTNO ; 


=> display  ENAME  DNAME working at NEW YORK loc ? 

      SELECT E.ENAME,D.DNAME
         FROM  EMP E INNER JOIN DEPT D
              ON   E.DEPTNO = D.DEPTNO 
       WHERE  D.LOC = 'NEW YORK' ; 

          ON  => join conditions
         WHERE => filter  conditions 

outer join :- 
----------------

 =>  inner join returns only matching records but cannot return unmatched records ,
       to get unmatched records perform outer join. 

  EMP				DEPT
  EMPNO  ENAME  SAL  DEPTNO            DEPTNO	DNAME		LOC
  1              A             3000 10		10	ACCOUNTS		
  2              B             4000 20		20	RESEARCH
  3              C            5000 30		30	SALES
  4              D            3000 10		40	OPERATIONS  => unmatched row
  5              E            2000 NULL => unmatched row

 => outer join is 3 types 

 1 left outer join
 2 right outer join
 3 full outer join

Left outer join :- 
-------------------

 =>  It returns all rows (matched + unmatched) from left side table and matching rows
       from right side table.

     SELECT  E.ENAME,D.DNAME
       FROM   EMP E , DEPT D
    WHERE  E.DEPTNO = D.DEPTNO (+) ;

  => above query returns all rows from emp and matching rows from dept
 
       A	ACCOUNTS
      B	RESEARCH
      C	SALES
      D	ACCOUNTS
      E	NULL   =>   unmatched from emp 

right outer join :- 
-----------------------

 => it returns all rows from right side table and matching rows from left side table

       SELECT  E.ENAME,D.DNAME
       FROM   EMP E , DEPT D
      WHERE  E.DEPTNO(+) = D.DEPTNO ;

 => return all rows from dept table and matching rows from emp table

     A	ACCOUNTS
     B	RESEARCH
     C	SALES
     D	ACCOUNTS
    NULL    OPERATIONS  => unmatched from dept 

 FULL OUTER JOIN :- 
 -----------------------------

  => returns all rows from both tables.

     SELECT  E.ENAME,D.DNAME
       FROM   EMP E , DEPT D
      WHERE  E.DEPTNO(+) = D.DEPTNO(+)  ;  => ERROR
                    
  => Native style doesn't support full outer join , to perform full outer join
       combine the outputs of left outer & right outer by using UNION operator.

    SELECT  E.ENAME,D.DNAME
       FROM   EMP E , DEPT D
      WHERE  E.DEPTNO = D.DEPTNO(+)  
    UNION
  SELECT  E.ENAME,D.DNAME
       FROM   EMP E , DEPT D
      WHERE  E.DEPTNO(+) = D.DEPTNO ;

 ANSI style :- 
 ------------------
 
 left outer join :- 
---------------------

SELECT E.ENAME,D.DNAME
   FROM EMP E  LEFT OUTER JOIN DEPT D
        ON  E.DEPTNO = D.DEPTNO ; 

 right outer join :- 
-------------------------

 SELECT E.ENAME,D.DNAME
   FROM EMP E  RIGHT OUTER JOIN DEPT D
        ON  E.DEPTNO = D.DEPTNO ;

full outer join :- 
----------------------

 SELECT E.ENAME,D.DNAME
   FROM EMP E  FULL OUTER JOIN DEPT D
        ON  E.DEPTNO = D.DEPTNO ;

 scenario :- 
 ---------------

 EMP			  PROJECTS
 EMPID  ENAME    PROJID	  PROJID	NAME  DURATION COST  CLIENT
 1	A	100	 100	X          3 YEARS    500      TATA MOTORS
 2	B	101            101
 3	C	NULL         102
 
=> display employee details with project details ?
 
=> display employee details with project details and also display employees not assigned to 
     any project ? 

=> display employee details with project details and also display projects where no
     employee assigned to it ?

 Displaying unmatched records :- 
 ----------------------------------------------

 left side table :- 
 ---------------------
 
SELECT E.ENAME,D.DNAME
   FROM EMP E  LEFT OUTER JOIN DEPT D
        ON  E.DEPTNO = D.DEPTNO 
 WHERE  D.DNAME IS NULL  ;

   E 	NULL

 right side table :- 
------------------------
 
 SELECT E.ENAME,D.DNAME
   FROM EMP E  RIGHT OUTER JOIN DEPT D
        ON  E.DEPTNO = D.DEPTNO 
  WHERE E.ENAME IS NULL ; 

        NULL	OPERATIONS

 both tables :- 
-------------------

 SELECT E.ENAME,D.DNAME
   FROM EMP E  FULL OUTER JOIN DEPT D
        ON  E.DEPTNO = D.DEPTNO 
  WHERE D.DNAME IS NULL
                 OR
                E.ENAME IS NULL ; 

  E	NULL
NULL	OPERATIONS

Non Equi Join :- 
------------------------

 => Non Equi Join is performed between the tables not sharing a common field.
 => here join condition is not based on "=" operator and it is based on >   <   between operators.
 
   SELECT columns
   FROM tabnames
   WHERE join condition ; 

 ex :- 

  EMP				SALGRADE
  EMPNO	 ENAME	SAL		GRADE	LOSAL	HISAL
  1	A	3000		1	700	1000
  2	B	1500		2	1001	2000
  3	C	5000		3	2001	3000
  4	D	2000		4	3001	4000
  5	E	2500		5	4001	9999

=>  Display   ENAME    SAL   GRADE   ?
                     -------------------    ------------
                         EMP               SALGRADE

    SELECT E.ENAME,E.SAL,S.GRADE
      FROM  EMP E , SALGRADE S
    WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL ; 

 A	3000	3
 B	1500	2
 C	5000	5
 D	2000	2
 E	2500	3

05-oct-23

ANSI style :- 
-----------------

 SELECT E.ENAME,E.SAL,S.GRADE   
   FROM  EMP E JOIN SALGRADE S
        ON  E.SAL BETWEEN S.LOSAL AND S.HISAL ;

=> display grade 3 employee list ? 

  SELECT E.ENAME,E.SAL,S.GRADE   
     FROM  EMP E JOIN SALGRADE S
          ON  E.SAL BETWEEN S.LOSAL AND S.HISAL 
  WHERE S.GRADE = 3; 

 => display   ENAME	      DNAME     GRADE    ?
                    -----------      -----------    ------------
                      EMP          DEPT        SALGRADE 

     SELECT columns
     FROM tab1 JOIN tab2
          ON join condition
                        JOIN  tab3
          ON join condition
                       JOIN tab4
         ON join condition ; 

    SELECT  E.ENAME,D.DNAME,S.GRADE
       FROM  EMP E  INNER JOIN DEPT D
            ON  E.DEPTNO = D.DEPTNO 
                                JOIN SALGRADE S
            ON  E.SAL BETWEEN S.LOSAL AND S.HISAL ; 

 
 EMP					SALGRADE
 EMPNO ENAME  SAL  DEPTNO		GRADE	LOSAL	HISAL
 1	A           3000  10			1	700	1000
 2             B           1000   20			2	1001	2000
 3              C           5000  30			3	2001	3000
					4	3001	4000
					5	4001	9999
ON E.SAL BETWEEN S.LOSAL AND S.HISAL :-
----------------------------------------------------------------

RESULT1			DEPT
1   A   3000  10   3		DEPTNO	DNAME	LOC
2  B   1000   20  1		10	ACCT
3  C   5000  30   5		20	RESEARCH
			30	SALES

ON  E.DEPTNO = D.DEPTNO :- 
--------------------------------------------

RESULT2
1   A   3000  10   3	ACCT
2  B   1000   20  1    RESEARCH
3  C   5000  30   5    SALES

SELECT  E.ENAME,D.DNAME,S.GRADE :- 
----------------------------------------------------------

  A    ACCT     	3
 B    RESEARCH	1
 C   SALES	5


SELF JOIN :- 
------------------

 => joining a table to itself is called self join.
 => in self join a record in one table joined with another record of same table.
 
 ex :- 

  EMP
  EMPNO  ENAME   MGR
  7369       smith       7902
  7499       allen        7698
  7698       blake       7839
  7839       king         NULL
  7902       ford         7566

 => above table contains mgr number but to display manager name we need to 
      perform self join.

 => to perform self join the same table must be declared two times with different
      alias  in   FROM clause

              FROM  emp x  JOIN  emp y 
 
  EMP X					EMP Y
  EMPNO  ENAME   MGR			EMPNO	ENAME	MGR
  7369       smith       7902			7369	smith	7902			
  7499       allen        7698			7499	allen	7698
  7698       blake       7839			7698	blake	7839
  7839       king         NULL			7839	king	 NULL
  7902       ford         7566			7902	ford	7566

 => display   ENAME   MGRNAME   ? 

     SELECT  X.ENAME,Y.ENAME AS MANAGER
     FROM EMP X JOIN EMP Y
          ON  X.MGR = Y.EMPNO ;

=> display employee list reporting to blake ? 

 SELECT  X.ENAME,Y.ENAME AS MANAGER
     FROM EMP X JOIN EMP Y
          ON  X.MGR = Y.EMPNO 
    WHERE Y.ENAME='blake' ; 
 

06-OCT-23

=> display blake's manager name ?

      SELECT  X.ENAME,Y.ENAME AS MANAGER
         FROM EMP X JOIN EMP Y
              ON  X.MGR = Y.EMPNO 
     WHERE  X.ENAME='blake' ; 

=> employees earning more than their managers ?

   SELECT  X.ENAME,Y.ENAME AS MANAGER
         FROM EMP X JOIN EMP Y
              ON  X.MGR = Y.EMPNO 
     WHERE  X.SAL > Y.SAL ; 

=> employees joined before their manager ?

       SELECT  X.ENAME,X.HIREDATE,
                        Y.ENAME AS MANAGER , Y.HIREDATE AS MGRHIRE
         FROM EMP X JOIN EMP Y
              ON  X.MGR = Y.EMPNO 
     WHERE  X.HIREDATE   <   Y.HIREDATE ;

=> display    ENAME	  DNAME	   GRADE	    	MNAME   ? 
                     ------------  ------------    ------------    	-------------
                       EMP       DEPT       SALGRADE   	EMP


   SELECT  E.ENAME,
                   D.DNAME,
                   S.GRADE,
                   M.ENAME
  FROM      EMP  E   INNER JOIN DEPT D
       ON      E.DEPTNO = D.DEPTNO 
                                  JOIN SALGRADE S
       ON     E.SAL BETWEEN S.LOSAL AND S.HISAL
                                  JOIN EMP M
       ON     E.MGR = M.EMPNO ; 

=> 

   TEAMS
   ID	COUNTRY
  1	IND 
  2	AUS
  3	ENG

=> Write a query to display following output ? 

  IND  VS   AUS
  IND  VS   ENG
  AUS VS  ENG

 CROSS JOIN / CARTESIAN JOIN :-
 ---------------------------------------------------

 => cross join returns cross product of two tables
 
   A = 1,2
   B = 3,4

  AXB  = (1,3) (1,4) (2,3) (2,4) 

 => if cross join performed between two table then all records of 1st table joined with
      all records of 2nd table.

 => to perform cross join submit the join query without join condition

   SELECT E.ENAME,D.DNAME
      FROM  EMP E,DEPT D  ;
 
 ANSI style :- 

  SELECT E.ENAME,D.DNAME
      FROM  EMP E CROSS JOIN DEPT D  ;
 
Questions :- 
----------------

1

 EMP				DEPT 
 EMPNO  ENAME   DNO		 DNO	DNAME	 EMPNO
 1              A              10		 10	HR	 1
 2             B               20		 20	IT	 2


=> display employee details with  dept details ? 

=> display  dept names and mgr names ? 


2

   T1		T2
   F1		C1
   10		A
   20		B
   30		C


 output :- 

  10	A
  20	B
  30	C
 

GROUP BY & JOIN :- 
 ------------------------------

=> display  dept  twise total sal ? display dept names ?

    SELECT D.DNAME , SUM(E.SAL) 
    FROM  EMP E INNER JOIN DEPT D
         ON   E.DEPTNO = D.DEPTNO
   GROUP BY D.DNAME ;

 ON   E.DEPTNO = D.DEPTNO :-
 -----------------------------------------------

  EMP					DEPT
  EMPNO	ENAME	SAL	DEPTNO		DEPTNO	DNAME	
  1	A	3000	10 		10	ACCTS
   2	B	4000	20		20	RESEARCH
   3	C	5000	30		30	SALES
  4	D	2000	10 
  5	E	3000	20

output :- 

   1	A	3000	10    ACCT
   2	B	4000	20   RESEARCH
   3	C	5000	30   SALES
   4	D	2000	10   ACCT
  5	E	3000	20  RESEARCH

  GROUP BY D.DNAME  :- 
  -------------------------------------
   
    ACCT	 	1	A	3000
	 	4	D	2000

   RESEARCH	2	B	4000
		5	E	3000

   SALES		3	C	5000

 SELECT D.DNAME , SUM(E.SAL)  :- 
 -----------------------------------------------------

ACCT		5000
RESEARCH	7000
SALES		5000

Assignment :- 
------------------

1   display no of employees working under each manager ?

2   display grade wise no of employees ?
 
3

    SALES
    DATEID	  	  PRODID    CUSTID   QTY   AMT
    05-OCT-23	 100	   10	   1       2000

    PRODUCTS
    PRODID	PNAME	PRICE	CATEGORY
    100		A	2000	ELECTORNICS

   CUST
   CUSTID	   NAME  ADDR   COUNTRY
    10	   A	HYD	IND

 1   display category wise total amount ?
 2   display country wise total amount ?
 3   display year wise,country wise,category wise total amount ?

==================================================================

07-OCT-23

SET OPERATORS :- 
----------------------------

 UNION
 UNION ALL
 INTERSECT
 MINUS

 A = 1,2,3,4
 B = 1,2,5,6

 A UNION B 	=  1,2,3,4,5,6
 A INTERSECT B 	=  1,2
 A MINUS	B	=   3,4
 B MINUS A               	=   5,6

=> In oracle set operations performed between rows return by two queries.

  SELECT  STATEMENT 1
  UNION / UNION ALL / INTERSECT / MINUS
  SELECT STATEMENT 2 ; 

  rules :- 

  1  both queries must return same no of columns
  2  corresponding columns datatype must be same

  UNION :- 
  -------------

  => combines rows return by two queries
  => eliminates duplicates 
  => sorts result 

  SELECT job FROM emp WHERE deptno = 20 ;

CLERK
MANAGER
ANALYST
CLERK
ANALYST

SELECT job FROM emp WHERE deptno = 30 ; 

SALESMAN
SALESMAN
SALESMAN
MANAGER
SALESMAN
CLERK

 SELECT job FROM emp WHERE deptno = 20 
 UNION
 SELECT job FROM emp WHERE deptno = 30 ; 

  ANALYST
 CLERK
 MANAGER
 SALESMAN
 

 SELECT job,sal FROM emp WHERE deptno = 20 
 UNION
 SELECT job,sal FROM emp WHERE deptno = 30 ; 


JOB              	SAL
--------- 		----------
ANALYST        	 3000
CLERK            	 800
CLERK            	 950
CLERK           	1100
MANAGER         	2850
MANAGER         	2975
SALESMAN       	1250
SALESMAN        	1500
SALESMAN        	1600

UNION VS JOIN :- 
-------------------------

		union			join

	1	combines rows		combines columns

	2	horizontal merge		vertical merge

	3	only similar structures	dissimilar structure can also
		can be combined with		be joined
		union


T1	T2	
F1	C1
1	10
2	20
3	30

UNION :- 			JOIN  :- 

1			1         10	
2                                                   2          20
3                                                   3          30
10
20
30

scenario :-
--------------

 EMP_US
 ENO	ENAME	SAL	DNO

					 DEPT
EMP_IND					 DNO	DNAME	LOC
ENO	ENAME	SAL	DNO


=> total employee list ?

 SELECT * FROM EMP_US
 UNION
 SELECT * FROM EMP_IND ; 

=>  employees working at US loc with dept details ?

     SELECT E.*,D.*
     FROM EMP_US  E   INNER JOIN DEPT D
          ON  E.DNO = D.DNO ;

=> total employee list with dept details ?

       SELECT E.*,D.*
           FROM EMP_US  E   INNER JOIN DEPT D
                ON  E.DNO = D.DNO
        UNION
       SELECT E.*,D.*
           FROM EMP_IND  E   INNER JOIN DEPT D
                ON  E.DNO = D.DNO ;

 UNION ALL :- 
 -------------------

  => combines rows return by two queries
  => duplicates are not eliminated
  => result is not sorted 

  SELECT job FROM emp WHERE deptno = 20 
  UNION ALL
  SELECT job FROM emp WHERE deptno = 30 ; 

CLERK
MANAGER
ANALYST
CLERK
ANALYST
SALESMAN
SALESMAN
SALESMAN
MANAGER
SALESMAN
CLERK

=> difference between union & union all ?

     	 union			union all

 1       eliminates duplicates		doesn't eliminate duplicates

 2       sorts result			result is not sorted

 3      slower			faster

 INTERSECT :- 
 ---------------------

  => returns common values from the output of two queries 

   SELECT job FROM emp WHERE deptno = 20 
   INTERSECT
   SELECT job FROM emp WHERE deptno = 30 ; 
  
   CLERK
   MANAGER

MINUS :- 
--------------

 => returns values present in 1st query output and not present in 2nd query output

   SELECT job FROM emp WHERE deptno = 20 
   MINUS
   SELECT job FROM emp WHERE deptno = 30 ; 
 
   ANALYST

   SELECT job FROM emp WHERE deptno = 30 
   MINUS
   SELECT job FROM emp WHERE deptno = 20 ; 

  SALESMAN 
   
 Question :- 

 T1		T2
 F1		C1
 1		1
 2		2
 3		3
 10		50
 20		60
 30		70

write the output for following operations ?

 1  INNER JOIN
 2  LEFT OUTER 
 3 RIGHT OUTER
 4 FULL OUTER
 5 UNION
 6 UNION ALL
 7 INTERSECT
 8 MINUS

  9-oct-23 

 SUB-QUERIES / NESTED QUERIES :- 
 ----------------------------------------------------

 => a query in another query is called sub-query  or nested query.
 => one query is called inner/child/sub query and other query is called outer/parent/main query
 => first oracle executes inner query then it executes outer query
 => result of inner query is input to outer query.
 => use subqueries when where cond based on unknown value.

   Types of subqueries :- 
  -----------------------------

  1  single row subqueries 
  2  multi row subqueries
  3 co-related subqueries 
  4 inline views
  5 scalar subqueries 

 single row subqueries :- 
 -------------------------------

=> if inner query returns one value then it is called single row subquery

     SELECT columns
     FROM tabname
     WHERE colname OP (SELECT STATEMENT);

=> OP must be   =   >    >=    <    <=    <>

 Ex :- 

  =>  employees earning more than blake ?
  
       SELECT *
       FROM emp 
       WHERE sal > (SELECT sal FROM emp WHERE ename='blake');

 => employees who are senior to king ?

     SELECT *
     FROM emp
    WHERE hiredate < (SELECT hiredate FROM emp WHERE ename='king') ;

=> name of the employee earning max salary ?

    SELECT  ename
    FROM emp 
    WHERE sal =  MAX(sal) ;   => error 

   => group functions are not allowed in where and they are allowed only in
        select,having clauses.

    SELECT  ename
    FROM emp 
    WHERE sal =  (SELECT MAX(sal) FROM emp) ; 
                            ----------------------------------------------
                                         5000
                                                       
 => name of the employee having max experience ?

     SELECT ename
     FROM emp 
     WHERE hiredate = (SELECT MIN(hiredate) FROM emp) ; 
                                     -----------------------------------------------
                                           17-dec-80

  => employees having min,max experience ?

     SELECT ename,hiredate
     FROM emp 
     WHERE hiredate = (SELECT MIN(hiredate) FROM emp)  
                   OR
                   hiredate = (SELECT MAX(hiredate) FROM emp) ;
   
 => display 2nd max salary ?

     SELECT MAX(sal)  
     FROM emp 
     WHERE  sal <> (SELECT MAX(sal) FROM emp) ;
                                ------------------------------------------
                                             5000
 
    o/p :- 3000

=> name of the employee earning 2nd max salary ?

     SELECT ename,sal
     FROM emp 
     WHERE sal =  (SELECT MAX(sal) 
                               FROM emp 
                               WHERE  sal <> (SELECT MAX(sal) FROM emp));
                                                          ------------------------------------------
                                                                       5000
                               -----------------------------------------------------------------
                                         3000

 => delete the employee having max experience ? 

     DELETE 
     FROM emp 
     WHERE hiredate = (SELECT MIN(hiredate) FROM emp);

 => increment sal of the employee having max experience by 10% ?

       UPDATE emp 
       SET sal = sal + (sal*0.1)
       WHERE hiredate = (SELECT MIN(hiredate) FROM emp) ; 

 => swap employee salaries whose empno = 7369,7499 ?

      before swap		after swap
      7369    800		7369	1600
      7499    1600		7499	800

     UPDATE emp 
     SET sal = CASE empno
	     WHEN 7369 THEN  (SELECT sal FROM emp WHERE empno=7499)
                      WHEN 7499 THEN (SELECT sal FROM emp WHERE empno=7369)
                      END  
    WHERE empno IN (7369, 7499) ; 
 
  10-OCT-23  :- 

  => find the depts whose avg(sal) greather 20th dept avg(sal) ? 

      SELECT DEPTNO,AVG(SAL)
      FROM EMP
      GROUP BY DEPTNO 
      HAVING AVG(SAL) >  (SELECT AVG(SAL) FROM EMP WHERE DEPTNO=20)    ;   
                                          --------------------------------------------------------------------------- 
                                                              2175

   => find the dept having max no of employees ?

        SELECT DEPTNO
        FROM EMP
        GROUP BY DEPTNO
        HAVING COUNT(*) =  (SELECT MAX(COUNT(*))
                                              FROM EMP
                                              GROUP BY DEPTNO) ; 

      o/p :- 30 

 
 =>  in which year max no of employees joined ?

 => on which day max no of employees joined ? 

 => under which manager max no of employees working ?

 Multi-row subqueries :- 
 -----------------------------

 => if subqueries returns more than one value then it is called multi-row subquery.

   SELECT COLUMNS
   FROM TABNAME
   WHERE COLNAME OP (SELECT STMT) ; 

  => OP  must be    IN,NOT IN,ANY,ALL 

 EX :- 

 => employees working at NEW YORK,CHICAGO locations ?

 using subquery :- 
 -------------------------

      SELECT EMPNO,ENAME,SAL,DEPTNO
     FROM EMP
     WHERE  DEPTNO  IN  (SELECT DEPTNO
                                            FROM DEPT
                                            WHERE LOC IN ('NEW YORK','CHICAGO'))
 
  using join :-
 ----------------

   SELECT E.ENAME,E.SAL 
   FROM EMP E INNER JOIN DEPT D
        ON E.DEPTNO = D.DEPTNO
  WHERE D.LOC IN ('NEW YORK','CHICAGO') ;


=>  employee details with dept details working at NEW YORK,CHICAGO locations ?

  
 USING JOIN :- 
 ---------------------

  SELECT E.ENAME,E.SAL,D.DNAME,D.LOC
   FROM EMP E INNER JOIN DEPT D
        ON E.DEPTNO = D.DEPTNO
  WHERE D.LOC IN ('NEW YORK','CHICAGO') ;

USING SUBQUERY :- 
-----------------------------

  NOT POSSIBLE

  difference between join and subquery ?

  => to display data from one table and condition based on another table then we can use 
       join and subquery.

 => to display data from two tables use join operation.

 ANY operator / ALL operator :- 
 ----------------------------------------

  => use ANY operator for  >   <  comparision with multiple values. 

                                   SINGLE		MULTI

		 =		IN

		>		>ANY        >ALL

		<		<ANY	<ALL

  ex :-  

              WHERE X  >  ANY(1000,2000,3000) 

                IF X = 800   	FALSE
                           1500	TRUE
	          4500                TRUE

             WHERE X < ANY(1000,2000,3000)

              IF  X = 800       TRUE
                         1500      TRUE
                         4500      FALSE

             WHERE X > ALL(1000,2000,3000)

                 IF X = 800    FALSE
                           1500   FALSE
                           4500   TRUE

              WHERE X < ALL(1000,2000,3000)

              IF X=800    TRUE
                      1500   FALSE
                      4500   FALSE

 => employees earning more than all managers ?

     SELECT *
     FROM EMP
     WHERE SAL >  ALL (SELECT SAL  FROM EMP WHERE JOB='MANAGER') ;          
                                       -----------------------------------------------------------------------                             
			      2975,2850,2450

  => employees earning more than atleast one manager ? 
		
     SELECT *
     FROM EMP
     WHERE SAL >  ANY (SELECT SAL  FROM EMP WHERE JOB='MANAGER') ; 

11-oct-23

 CO-RELATED SUBQUERIES :- 
 ----------------------------------------

 =>  if inner query references values of outer query  then it is called co-related subquery
 
=>  here execution starts from outer query and inner query is executed no of times
      depends on no of rows return by outer query.

=> use co-related subqueries to execute subquery for each row.

 ex :- 

    EMP
    EMPNO   ENAME   SAL    DEPTNO
    1               A              5000   10
    2              B              3000    20
    3              C              6000    30
    4              D              2000    10
    5              E              4000     20

  => employees earning more than avg(sal) of their dept ? 

       where sal >  (employee dept avg(sal))

    SELECT *
    FROM EMP X
   WHERE SAL > (SELECT AVG(SAL) FROM EMP WHERE DEPTNO =  X.DEPTNO) ;

 1               A              5000   10              5000 > (3500)    TRUE
 2              B              3000    20              3000 > (3500)   FALSE
 3              C              6000    30             6000 > (6000)    FALSE
 4              D              2000    10             2000 > (3500)    FALSE
 5              E              4000     20            4000 > (3500)    TRUE

=> employees earning max sal in their dept ? 

     SELECT ename,sal,deptno
      FROM emp x
     WHERE sal = (SELECT MAX(sal) FROM emp WHERE deptno = x.deptno) ;

    1               A              5000    10       5000 = (5000)   TRUE
    2              B              3000     20       3000 = (4000)   FALSE
    3              C              6000     30       6000 = (6000)   TRUE
    4              D              2000     10       2000 = (5000)   FALSE
    5              E              4000      20      4000 = (4000)   TRUE

 => display top 3 max salaries ? 

      SAL
      5000
      1000
      3000
      2000
      4000

      SELECT  DISTINCT A.SAL
      FROM EMP A
      WHERE  3 > (SELECT COUNT(DISTINCT B.SAL)
                              FROM EMP B
                             WHERE A.SAL < B.SAL) 
     ORDER BY SAL DESC ; 

       EMP A	EMP B
      SAL		SAL
      5000		5000		3 > (0)   TRUE
      1000		1000		3 > (4)   FALSE
      3000		3000		3 > (2)   TRUE
      2000		2000		3 > (3)   FALSE
      4000		4000		3 > (1)   TRUE


 => display Nth max sal ?

     SELECT  DISTINCT A.SAL
      FROM EMP A
      WHERE  (&N-1)   =     (SELECT COUNT(DISTINCT B.SAL)
                                         FROM EMP B
                                        WHERE A.SAL < B.SAL) 
     ORDER BY SAL DESC ; 

12-OCT-23

ROWID :- 
--------------

 => returns physical address of a row i.e. where record is stored in memory
 => rowid is called psuedo column because it is not a column but acts like  a column.

 PSUEDO COLUMN :- 
 -----------------------------

 1 ROWID
 2 ROWNUM
 3 LEVEL
 4 SYSDATE
 5 USER

=>  to display rowids 

   SELECT ROWID,EMPNO,ENAME,SAL FROM EMP ; 

=> Query to find amount of memory consumed by table ? 

SELECT SUM(VSIZE(EMPNO) + 
                         VSIZE(ENAME) + 
                         VSIZE(JOB) + 
                         VSIZE(NVL(MGR,0)) +
                         VSIZE(HIREDATE) + 
                         VSIZE(SAL) + 
                         VSIZE(NVL(COMM,0)) +
                         VSIZE(DEPTNO))
 AS VSIZE
FROM EMP ;
 
=> ROWIDs are used to delete duplicate records 

ex :- 

 EMP44
 ENO	ENAME	SAL			ROWID	
 1	A	5000			AAA
 2	B	6000			AAB
 3	C	7000			AAC
 1	A	5000 => duplicate		AAD		
 2	B	6000 => duplicate		AAE
 
 DELETE FROM EMP44 WHERE ROWID  LIKE '%AAD' ;

 DELETE FROM EMP44 WHERE ROWID  LIKE '%AAE' 

NOTE :- 

 => deleting duplictes row-by-row is difficult if table contains huge number of duplicate
      rows , so execute the following query to delete all duplicate records.

    DELETE 
    FROM  EMP44 X
    WHERE  ROWID <> (SELECT MIN(ROWID)
                                          FROM EMP44
                                          WHERE ENO = X.ENO
                                                         AND
                                                         ENAME=X.ENAME
                                                         AND
                                                         SAL = X.SAL);

 EMP44
 ENO	ENAME	SAL	ROWID	
 1	A	5000	AAA     <>   (AAA)   FALSE
 2	B	6000	AAB     <>   (AAB)   FALSE
 3	C	7000	AAC    <>   (AAC)   FALSE
 1	A	5000 	AAD    <>   (AAA)   TRUE	
 2	B	6000	AAE    <>   (AAB)   TRUE

 => command to display duplicate records ?

    SELECT * 
    FROM  EMP44 X
    WHERE  ROWID <> (SELECT MIN(ROWID)
                                          FROM EMP44
                                          WHERE ENO = X.ENO
                                                         AND
                                                         ENAME=X.ENAME
                                                         AND
                                                         SAL = X.SAL);
 
 INLINE views :- 
 ----------------------

=>  subqueries in FROM clause are called inline views

      SELECT columns
      FROM  (SELECT stmt)   <ALIAS>
     WHERE COND ; 

  => subquery output acts like  a table for outer query.

  => INLINE views are used in following scenarios 

   1  to control order of execution of clauses
   2  to use result of one operation in another operation
   3  to join two query outputs 

 controlling order of execution of clauses :- 
 ---------------------------------------------------------

 default order :- 
 ---------------------

 FROM
WHERE
GROUP BY
HAVING
SELECT
ORDER BY

=> to control this order of execution use INLINE views 

 example 1 :-  

 => display  ranks of the employees based on sal ? 

    SELECT EMPNO,ENAME,SAL,
                    DENSE_RANK() OVER (ORDER BY SAL DESC)  AS RNK
    FROM EMP ; 

  above query returns ranks of all the employees but to display top 5 employees 

    SELECT EMPNO,ENAME,SAL,
                    DENSE_RANK() OVER (ORDER BY SAL DESC)  AS RNK
    FROM EMP 
    WHERE RNK <= 5 ;      => ERROR

   above query returns error because column alias cannot be used in where clause
   because where clause is executed before select. To overcome this problem use INLINE views

   SELECT *
   FROM ( SELECT EMPNO,ENAME,SAL,
                      DENSE_RANK() OVER (ORDER BY SAL DESC)  AS RNK
                FROM EMP )  E
   WHERE  RNK<=5 ;

 => to display top 5 max salaries ? 

   SELECT DISTINCT SAL
   FROM ( SELECT SAL,
                      DENSE_RANK() OVER (ORDER BY SAL DESC)  AS RNK
                FROM EMP )  E
   WHERE  RNK<=5 ;

  SELECT DISTINCT SAL
  FROM E
  WHERE RNK<=5 ;
 
  => to display 5th max salary ? 

   WHERE RNK = 5 ; 

13-OCT-23 

 => display top 3 employees with in dept ?

       SELECT *
       FROM ( SELECT  DEPTNO,EMPNO,ENAME,SAL, 
                             DENSE_RANK() OVER (PARTITION BY DEPTNO
                                                                     ORDER BY SAL DESC) AS RNK
                     FROM EMP ) E
        WHERE RNK<=3;
    
  => display top 3 max salaries in each dept ? 

  SELECT DISTINCT DEPTNO,SAL
  FROM ( SELECT  DEPTNO,SAL,
                            DENSE_RANK() OVER (PARTITION BY DEPTNO
                                                                        ORDER BY SAL DESC) AS RNK
              FROM EMP ) E
   WHERE RNK<=3 ;
  

ROWNUM :- 
-----------------

 => rownum returns record numbers for the records return by query.

 => rownum is also a psuedo column because it is not a column but
      acts like a column
  
  ex :-  SELECT ROWNUM,EMPNO,ENAME,SAL FROM EMP ; 

	9    7839    KING

        SELECT ROWNUM,EMPNO,ENAME,SAL FROM EMP WHERE SAL>=2000;

               5   7839    KING

 => if query changes rownum also changes because rownum is not based on
      table and it is based on select stmt output.

 => rownum is useful when selecting records from table based on record number

     display first 5 rows from emp ?

    SELECT EMPNO,ENAME,SAL
    FROM EMP
    WHERE ROWNUM <= 5;     

    display 5th row ?

    SELECT EMPNO,ENAME,SAL
    FROM EMP
    WHERE ROWNUM  = 5;       =>  no rows 

  note :- 

  => in where conditions with rownum   =    >    >=   operators will not work
       only   <   <=  opertors can be used. To overcome this use INLINE views

   SELECT EMPNO,ENAME,SAL
   FROM (SELECT ROWNUM AS RNO,EMPNO,ENAME,SAL FROM EMP) E
   WHERE  RNO = 5 ; 
 
  WHERE RNO IN (5,7,11) ;

  WHERE RNO BETWEEN 5 AND 10 ; 
 
  WHERE MOD(RNO,2)=0 ;

  => display last 3 rows from table ?

      SELECT EMPNO,ENAME,SAL
      FROM (SELECT ROWNUM AS RNO,EMPNO,ENAME,SAL FROM EMP) E
      WHERE  RNO >= (SELECT COUNT(*)-2 FROM EMP) ; 

 Questions :- 

 1    T1
       AMT
       1000
       -200
       2000
      -500
      3000
      -700

 output :- 

     POS	    NEG
     1000	    -200
     2000       -500
     3000       -700

2
     T1		T2
     F1		C1
     1		A
     2		B
     3		C

  => write a query to join the two tables and display following output ?

  1	A
  2	B
  3	C

SELECT E1.F1,E2.C1
FROM (SELECT ROWNUM AS RNO,F1 FROM T1)  E1
            INNER JOIN
            (SELECT ROWNUM AS RNO,C1 FROM T2) E2
 ON E1.RNO = E2.RNO ;

3  write a query to display following output ?

  deptno	     1st  max	2nd max  
  10	     5000		2450
  20	     3000		2975
  20	     2850		1600

14-oct-23 

 scalar subqueries :- 
 --------------------------
 
 => subqueries in select clause are called scalar subqueries

      SELECT (subquery1),(subquery2),-------
      FROM tabname
      WHERE cond

 => subquery output acts like a column for outer query
 => use scalar subquery to show the query output in seperate column
 
 ex 1 :- 

    SELECT  (SELECT COUNT(*) FROM EMP) AS EMP ,
                   (SELECT COUNT(*) FROM DEPT) AS DEPT
    FROM DUAL ;

   EMP	DEPT
   14	4
    
ex 2 :- 

 display  DEPTNO    DEPT_TOTSAL     TOTSAL  ?

 SELECT DEPTNO,
                SUM(SAL) AS DEPT_TOTSAL,
               (SELECT SUM(SAL)  FROM EMP) AS TOTSAL
 FROM EMP 
 GROUP BY DEPTNO ; 

  DEPTNO DEPT_TOTSAL     TOTSAL
---------- 	----------- 		----------
        30        9400      	29025
        10        8750      	29025
        20       10875     	29025


 => display  DEPTNO   DEPT_TOTSAL     TOTSAL       PCT ?

      PCT  =   (DEPT_TOTSAL / TOTSAL)   * 100
 
 SELECT DEPTNO,
                SUM(SAL) AS DEPT_TOTSAL,
               (SELECT SUM(SAL)  FROM EMP) AS TOTSAL ,
               ROUND((SUM(SAL) / (SELECT SUM(SAL) FROM EMP))*100) AS PCT
 FROM EMP 
 GROUP BY DEPTNO ;

  DEPTNO 	DEPT_TOTSAL       TOTSAL        PCT
---------- 		---------------------	----------      ----------
        30        	9400      		29025         32
        10        	8750      		29025         30
        20       	10875      		29025         37

ex 3 :- 

      SELECT ENAME,SAL,(SELECT SUM(SAL) FROM EMP) AS TOTSAL
     FROM EMP;

ENAME          SAL        TOTSAL
---------- 	   ----------	    ----------
smith             800     	    29025
allen            1600         29025
ward             1250        29025
jones            2975        29025
martin           1250        29025


NOTE :-

 SELECT col1,col2   FROM tabname

 rule :-

  no of values return by col1 =  no of values return by col2


 1   SELECT  ENAME,SAL,SUM(SAL) FROM EMP ;     => ERROR
                      14         14       1 

 2  SELECT  ENAME,ROUND(SAL) AS SAL FROM EMP ;  => EXECUTED
                     14             14
 
 3 SELECT MIN(SAL),MAX(SAL) FROM EMP ;  => EXECUTED
                     1             1

 4  SELECT   ROUND(SAL),SUM(SAL) AS TOTSAL FROM EMP ; => ERROR 
                           14                  1

Assignment :- 

 SALES
 DATEID		 PRODID	  CUSTID	  QTY	AMT
 01-JAN-20	100	  10	  1	2000

PRODUCTS
PRODID	 PNAME	PRICE	CATEGORY
100	 KKK	2000	ELECTRONICS

 
=> display   CATETORY          CAT_TOT_AMT               TOTAL_AMT      PCT  ?
                   ELECTRONICS    280                                  1000		?
                   MENS                   80		      1000		?
                   WOMENS            100		      1000		?

PIVOT operator :- 
------------------------

 => pivot operator used to convert rows into columns
 => used to display data in matrix form
 => used for cross tabulation

 SELECT columns
 FROM (SELECT STATEMENT)  <ALIAS>
 PIVOT
   (
      AGGR-EXPR  FOR COLNAME IN (V1,V2,V3,--)
  )
 ORDER BY COLNAME ASC/DESC ;

Ex :- 

 			10	20	30

	analyst		?	?	?

	clerk		?	?	?

	manager		?	?	?

	salesman		?	?	?

    
 SELECT *
 FROM (SELECT DEPTNO,JOB,SAL FROM EMP)  E
 PIVOT
   (
       SUM(SAL) FOR DEPTNO IN (10,20,30)
  )
 ORDER BY JOB ASC ; 

ex 2 :- 

			1	2	3	4

	1980		?	?	?	?	

	1981		?	?	?	?

	1982		?	?	?	?
		
	1983		?	?	?	?


       SELECT *
       FROM (SELECT  TO_CHAR(HIREDATE,'YYYY') AS YEAR,
                                    TO_CHAR(HIREDATE,'Q') AS QRT,
                                    EMPNO
                   FROM EMP) E
       PIVOT
          (
               COUNT(EMPNO) FOR QRT IN (1,2,3,4)
          )
        ORDER BY YEAR ASC 

ex 3 :- 

    STUDENT
    SNO	SNAME	SUBJECT		MARKS
    1	A	MAT		80
    1	A	PHY		60
    1	A	CHE		50
    2	B	MAT		60   
    2	B	PHY		70
    2	B	CHE		40


 OUTPUT :-  
 
  SNO	SNAME	MAT	PHY	CHE
 1	A	80	60	50
 2	B	60	70	40

16-OCT-23 

 creating new table from existing table :- (creating replica)
 -------------------------------------------------------------------------------

 CREATE TABLE <NEW-TABNAME>
 AS
 SELECT COLUMNS FROM <OLD-TABNAME> ;

 EX :- 

 CREATE TABLE EMP11
 AS
 SELECT * FROM EMP ; 

=> above command copies all rows & cols from emp to emp11

 copying specific rows & cols :- 
 ------------------------------------------

 CREATE TABLE EMP22
 AS
 SELECT EMPNO,ENAME,JOB,SAL
 FROM EMP
 WHERE JOB IN ('CLERK','MANAGER');

 copy only structure but not data :- 
 ----------------------------------------------

 CREATE TABLE EMP33
 AS
 SELECT * FROM EMP  WHERE  1=2 ; 

 copying table from one user to another user :- 
 ---------------------------------------------------------------

=> copy emp table from user batch730 to vijay  ?

 SYSTEM :- 
 ---------------

 SQL>CREATE TABLE  VIJAY.EMP
          AS
          SELECT * FROM BATCH730.EMP ;

 copying data from one table to another table :- 
 ------------------------------------------------------------------  

 INSERT INTO <target-table>
 SELECT COLUMNS FROM <SOURCE-TABLE> ;

 ex :- 	

 => copy data from emp to emp33 ?

    INSERT INTO EMP33
    SELECT * FROM EMP ; 
 
 MERGE command :- 
 ----------------------------

 => command used to merge data into a table.
 => merge is the combintion of insert & update
 => used to manage replicas (duplicate copies)
 => used in ETL applications (Extract  Transform Load).
 => using merge we can apply changes made to source table to replica.
 
 MERGE INTO <target-table>  <alias>
 USING <source-table>  <alias>
 ON (condition)
 WHEN MATCHED THEN
     UPDATE
 WHEN NOT MATCHED THEN
    INSERT ;
 
 Example :- 

 STEP 1 :-  create source table

  CREATE TABLE CUSTS
  (
   CID NUMBER(2),
   CNAME VARCHAR2(10),
   CADDR   VARCHAR2(10)
  );

 INSERT INTO CUSTS VALUES(1,'A','HYD');
 INSERT INTO CUSTS VALUES(2,'B','BLR');

STEP 2 :- create target table

 CREATE TABLE CUSTT
 AS
 SELECT * FROM CUSTS ; 

STEP 3 :-  modify source table data

 INSERT INTO CUSTS VALUES(3,'C','DEL');

 UPDATE CUSTS SET CADDR='MUM' WHERE CID=1; 

STEP 4 :- apply changes to target table

 MERGE INTO CUSTT   T
 USING CUSTS  S
 ON (S.CID = T.CID)
 WHEN MATCHED THEN
     UPDATE  SET T.CADDR = S.CADDR
 WHEN NOT MATCHED THEN
    INSERT VALUES(S.CID,S.CNAME,S.CADDR) ;

 
 CUSTS				CUSTT	
 CID	NAME	CADDR		CID	NAME	CADDR
 1	A	MUM		1	A	MUM
 2	B	BLR		2	B	BLR
 3	C	DEL		3	C	DEL
 
 Assignment :- 

 EMPS				EMPT
EMPNO	ENAME	SAL		EMPNO	ENAME	SAL
1	A	5000		1	A
2	B	6000		2	B
3	C	7000		3	C


copy salaries from emps to empt ?

method 1
method 2 

17-OCT-23

simple select stmt
where 
order by
distinct
fetch
functions
group by & having
joins
set operators
subqueries 

DATABASE TRANSACTIONS :-
------------------------------------------

=> a  transaction is a unit of work that contains one or more dmls and must be
     saved as a whole or must be cancelled as a whole.
  
 ex :-  money transfer

          acct1--------------------1000---------------------------acct2

          update1				update2
          (bal=bal-1000)                                                  (bal =bal + 1000)

         successful                                                         failed             INVALID

         failed                                                                 successful    INVALID

        successful				successful     VALID

        failed                                                                  failed              VALID


  => every transaction must gurantee a property called " atomocity " i.e.
       all or none i.e. if transaction contains multiple dmls  if all are successful
       then it must be saved , if one of the  operation fails then entire transaction
       must be cancelled.

 => to handle transactions the following commands provided by oracle called
      TCL (transaction control lang) commands

           1  COMMIT               =>  to save txn
           2  ROLLBACK          =>  to cancel txn
           3  SAVEPOINT         =>  to cancel part of the txn

   => every txn has a begin point and an end point

   => a txn begins automatically when user submits dml command to oracle

   => a txn ends automatically when user submits any of the following command

            1  COMMIT / ROLLBACK
            2  DDL command (txn ends with commit)

 example 1 :- 

  create table a(a number(2));
  insert into a values(10);       => txn begins T1
  insert into a values(20);
  insert into a values(30);
  insert into a values(40);
  commit ;                             => txn ends 

 => if txn ends with commit then it is called successful txn and operations are saved

example 2 :- 

  create table a(a number(2));   => commit
  insert into a values(10);          => txn starts t1
  insert into a values(20);
  insert into a values(30);
  insert into a values(40);
  rollback;                               => txn ends 

 => if txn ends with rollback then it is called aborted txn and operations are 
      cancelled

  => when commit is executed , db table is replaced with after image and 
       deletes before image.

 => when rollback is executed,  after image is replaced with before image
      and deletes before image.

 example 3 :- 

  create table a(a number(2));     => commit
  insert into a values(10);            => txn starts T1
  insert into a values(20);
  create table b(b number(2));    => commit
  insert into a values(30);           => txn starts T2
  insert into a values(40);
  rollback;                                   => txn ends 

  T1 => saved
  T2 => cancelled

SAVEPOINT :- 
---------------------

 => we can declare savepoint and we can rollback upto the savepoint
 => using savepoint we can cancel part of the txn

  create table a(a number(2));      
  insert into a values(10);           
  insert into a values(20);
  savepoint sp1;
  insert into a values(30);          
  insert into a values(40);
  savepoint sp2;
  insert into a values(50);          
  insert into a values(60);
  rollback to sp1;
 
 select * from a ;
 
10
20

18-OCT-23

 LOCKING :-
 ------------------
 
=> accessing same data by no of users at the same time is called concurrent access
=> when data accessed concurrently then user encounters following problems

     1 Dirty read
     2 lost update
     3 phantom read
     4 non repeatable read 

=> to overcome the problems of concurrent access every db supports a mechanism called
     locking mechanism.

=> locks are 2 types/modes   

    1  SHARED LOCK (S)
    2  EXCLUSIVE LOCK (X)

=> shared lock is applied when user is trying to read data (select stmt)
=> exclusive lock is applied when user is trying to update data (dml stmt)

		S	X

	S	YES	YES

	X	YES	NO

 
 Ex :-

         SYSTEM				                BATCH730

  1  UPDATE BATCH730.EMP			2	UPDATE EMP
      SET SAL = 2000					SET SAL=3000
      WHERE EMPNO = 7844 ;				WHERE EMPNO=7844 ;

     locked + updated 				---------wait---------------

3   COMMIT;				4	1 row updated 

     lock releases


DeadLock :- 
-----------------

 => Deadlock is the situation where two users mutually waits for one another, if deadlock
      occurs oracle throws error , so that one transaction can be cancelled and continue
      second transaction.

 ex :-
	
      SYSTEM				                BATCH730

  1  UPDATE BATCH730.EMP			2	UPDATE EMP
      SET SAL = 2000					SET SAL=3000
      WHERE EMPNO = 7499 ;				WHERE EMPNO=7844 ;

     locked + updated 				 locked + updated

  3  UPDATE BATCH730.EMP			4	UPDATE EMP
      SET SAL = 2000					SET SAL=3000
      WHERE EMPNO = 7844;				WHERE EMPNO=7499 ;
   
      --------wait---------------------				-------------wait-----------------

  -------------------------------------------------Deadlock--------------------------------------------------------------

 5   ERROR :- deadlock detected

 6   ROLLBACK;				7    COMMIT;	

 How to prevent deadlock :- 
---------------------------------------

 => lock the records that you want to update at the beginning of the transaction by executing
      the following query.
 
 SELECT *
 FROM EMP
 WHERE EMPNO IN (7499,7844)  FOR UPDATE ; 

 => oracle appliles exclusive lock on records return by select query

 TABLE LEVEL locking :-
 ------------------------------------

 => in table level whole table is locked i.e. all the records of table are locked

               LOCK  TABLE  <TABNAME>   IN   <MODE> 

    ex :-  

        SQL>LOCK TABLE EMP IN SHARED MODE ;

        SQL>LOCK TABLE EMP IN EXCLUSIVE MODE ; 


    NOTE :- table level locking prevents DDL operations 

  what are ACID properties /  transaction properties ?

  A   => atomocity
  C  => consistency
  I   =>  isolation
  D  => durability

 Atomocity :- 
 ------------------

  => atomocity means all or none , if transaction contains multiple operations , if all are 
       successful then it must be saved , if one of the opreation fails then entire transaction
       must be cancelled

Consistent :-
-------------------

=>  database state remains consistent before and after the transaction.
 

Isolatation :   transactions should not interfere with each other.
----------------
 
Durability : 
----------------

Once a transaction has been committed, the database changes are preserved, 
 even if the machine on which the database software is running crashes later.
 
  ==========================================================================

19-oct-23

 Database Security :- 
 ---------------------------

 1 USERS                    => provides security at db level
 2 PRIVILEGES           => provides security at table level
 3 VIEWS                    => provides security at row & col level

 DATABASE (USERS)
        TABLES  (PRIVILEGES)
                ROWS & COLS (VIEWS)

 CREATING USER IN ORACLE DB :- 
 ------------------------------------------------

 SYSTEM :- 
 ---------------

 SQL>CREATE USER NARESH IDENTIFIED BY ORACLE
          DEFAULT TABLESPACE USERS
          QUOTA UNLIMITED ON USERS ; 

 SQL>GRANT CONNECT,RESOURCE TO NARESH ;

           CONNECT    => to connect to db
           RESOURCE => to create objects like tables 
           DBA               =>  all permissions 
 
 changing password :- 
 -----------------------------

  => both user & dba can change password

   BY USER  :-   (NARESH/ORACLE)
  --------------------

  SQL> PASSWORD
Changing password for NARESH
Old password:  ORACLE
New password: TIGER
Retype new password: TIGER
Password changed

 BY DBA :-   (SYSTEM/TIGER)
-------------------------------------------

SQL>ALTER USER NARESH IDENTIFIED BY NIT ;

Changing DBA password :- 
-------------------------------------

  USERNAME :-  / AS SYSDBA

 SQL>ALTER USER SYSTEM IDENTIFIED BY MANAGER ; 

 Droping user :-    (SYSTEM)
 --------------------

    DROP  USER   <NAME>  [CASCADE]  ; 

 => if user is empty cascade is not required 
 => if user is not empty cascade is required

 SQL>DROP USER  VIJAY CASCADE ; 

 Locking & Unlocking  user :-  (SYSTEM)
 ---------------------------------------

SQL>ALTER USER NARESH ACCOUNT LOCK ; 

 SQL>ALTER USER NARESH ACCOUNT UNLOCK ; 

PRIVILEGES  :- 
----------------------

 => privileges means permissions 
 => permissions are granted to users by using GRANT command
 
     GRANT <privileges>  ON <tabname> TO <usernames> ;

   BATCH730 :- 
  --------------------

   SQL>GRANT ALL ON EMP TO NARESH ;

  NARESH :- 
  ----------------

  SQL>SELECT * FROM BATCH730.EMP ; 

  SQL>UPDATE BATCH730.EMP SET SAL = 2000 WHERE EMPNO = 7369 ; 

  NOTE :- changes made by one user are visilble to another user only after commit.

  Granting specific privileges :- 
  ----------------------------------------

  BATCH730 :- 

  SQL>GRANT SELECT,INSERT,UPDATE ON DEPT TO NARESH ; 

 NARESH :- 
 
 SQL>DELETE FROM BATCH730.DEPT WHERE DEPTNO = 10 ;  => ERROR

 Granting privileges to multiple users :- 
 --------------------------------------------------

BATCH730 :-

SQL>GRANT ALL ON EMP TO  NARESH,HR ; 


               BATCH730---------------EMP----------------->NARESH

              GRANTOR                                                   GRANTEE

  NOTE :- 

  => grantee  cannot grant permissions to another user

WITH GRANT OPTION :- 
 -----------------------------------

=> if permissions granted " WITH GRANT OPTION " then grantee can also grant
     permissions to another user

   BATCH730 :- 
   
  SQL>GRANT ALL ON SALGRADE TO  NARESH  WITH GRANT OPTION ; 

  NARESH :- 

  SQL>GRANT ALL ON BATCH730.SALGRADE TO HR ;

 20-oct-23

 REVOKE command :- 
 ----------------------------

  => command used to take back permissions from user

      REVOKE <privileges> ON <tabname> FROM <username> ;

 ex :- 

  BATCH730 :- 
  ------------------

 SQL>REVOKE ALL ON EMP FROM NARESH ; 

USER_TAB_PRIVS_MADE :- 
---------------------------------------

=> system table that stores information about privileges granted on tables to users 

 SQL>COLUMN TABLE_NAME FORMAT A10
 SQL>COLUMN GRANTEE FORMAT A10
 SQL>COLUMN PRIVILEGE  FORMAT A20
  
 SQL>SELECT PRIVILEGE,TABLE_NAME,GRANTEE
           FROM USER_TAB_PRIVS_MADE ;

USER_TAB_PRIVS_RECD :- 
---------------------------------------

 => stores privileges received and used by grantee

  SQL>COLUMN TABLE_NAME FORMAT A10
  SQL>COLUMN GRANTOR FORMAT A10
  SQL>COLUMN PRIVILEGE  FORMAT A20

 SQL>SELECT PRIVILEGE,TABLE_NAME,GRANTOR
           FROM USER_TAB_PRIVS_RECD ;

DB objects / SCHEMA objects / ORACLE objects  :-
---------------------------------------------------------------------

TABLES
VIEWS
SYNONYMS
SEQUENCES
MATERIALIZED VIEWS
INDEXES
CLUSTERS 

PL/SQL :- 

PROCEDURES
FUNCTIONS
PACKAGES
TRIGGERS 

VIEWS :- 
------------

=> a view is a subset of a table or part of a table.

=> a view is a virtual table because it doesn't store data and doesn't occupy memory
     and it always derives data from base table.

=> a view is a representation of a query.

 => views are created 

 1  to provide security
 2  to reduce complexity

=> view provides another level of security called row & col level i.e. with the help
     of views we can grant specific rows and columns to users

=> views are 2 types 

  1 simple views
  2 complex views 

 simple views :- 
 -------------------

 => if view created on single table then it is called simple view

 CREATE VIEW <NAME>
 AS
 SELECT STATEMENT ; 

Granting permissions to create view :-
---------------------------------------------------

SYSTEM :-
---------------

 SQL>GRANT CREATE VIEW TO BATCH730 ;

 BATCH730 :- 
 ------------------

 SQL>CREATE VIEW V1
          AS
          SELECT EMPNO,ENAME,JOB,HIREDATE,DEPTNO
          FROM EMP ;

 => oracle creates view V1 and stores query but not query output 

       SELECT * FROM V1 ; 

 => when above query submitted to oracle , it executes the query as follows

      SELECT * FROM 
                  (SELECT EMPNO,ENAME,JOB,HIREDATE,DEPTNO FROM EMP) ;

  Granting permissions on view to user :- 
  -----------------------------------------------------

   SQL>GRANT ALL ON V1 TO NARESH ;

  NARESH :- 
  -----------------

  SQL>SELECT * FROM BATCH730.V1 ; 

  SQL>UPDATE BATCH730.V1 SET JOB='MANAGER' WHERE EMPNO=7369;

  SQL>UPDATE BATCH730.V1 SET SAL=3000 WHERE EMPNO=7369; => ERROR

 
 27-oct-23

 Row level security :- 
 ---------------------------
 
CREATE VIEW V2
AS
 SELECT EMPNO,ENAME,JOB,DEPTNO 
 FROM EMP
 WHERE DEPTNO = 20 ;

GRANT ALL ON V2 TO NARESH ;

NARESH :- 

INSERT INTO BATCH730.V2 VALUES(100,'ABC','CLERK',30) ; => 1 row created

above  insert command executed successfully even though it's violating where cond.

WITH CHECK OPTION :- 
------------------------------------

 => if view created with  " WITH CHECK OPTION "  any dml command through view
      violates where cond then that dml is not accepted.

  CREATE VIEW V3
  AS
  SELECT EMPNO,ENAME,JOB,DEPTNO
  FROM EMP
  WHERE DEPTNO = 20
  WITH CHECK OPTION ; 

 GRANT ALL ON V3 TO NARESH 

NARESH :- 
---------------

 INSERT INTO BATCH730.V3 VALUES(101,'KLM','CLERK',30);  => ERROR

 Complex views :- 
 -----------------------

 => a view said to be complex view

     1  if based on mutliple tables
     2 if query contains group by clause
                                    distinct clause
                                    aggregate functions
                                    set operators
                                    subqueries


 => with the help of views complex queries can be converted into simple queries
 
  example 1 :- 
 
  CREATE VIEW CV1
  AS
  SELECT E.EMPNO,E.ENAME,E.SAL,
                  D.DEPTNO,D.DNAME,D.LOC
  FROM EMP E INNER JOIN DEPT D
       ON  E.DEPTNO = D.DEPTNO ; 

=> after creating view whenever we want data from emp & dept tables then 
     instead of writing join query write the simple query as follows 

      SELECT * FROM CV1 ; 

 example 2 :- 

 CREATE VIEW CV2
 AS
 SELECT D.DNAME,SUM(E.SAL) AS TOTSAL
 FROM EMP E INNER JOIN DEPT D
       ON E.DEPTNO = D.DEPTNO
 GROUP BY D.DNAME

 => after creating view whenever we want dept wise total sal then execute the following
      simple query

    SELECT * FROM CV2 ; 

  difference between simple and complex views ?

                  simple                                                        complex 

 1    based on single table                                          based on multiple tables
 
2    query performs simple		            query performs complex 
      operations                                                            operations like joins,group by etc

3    always updatable                                                  not updatable

=> list of views created by user ? 

    SELECT VIEW_NAME FROM USER_VIEWS ; 

=> display query associated with v1 ? 

   SELECT TEXT FROM USER_VIEWS WHERE VIEW_NAME='V1' ; 

Droping view :- 
---------------------

 DROP VIEW V1 ; 


if we drop table what about view created on table ?

ans :- views are not dropped but cannot be queried.

can we create a view from another view ?

ans :- yes 

can we create view without a base table ?

 ans :-  yes 

CREATE FORCE VIEW V20
AS
SELECT * FROM ABC ;

How to add a column to view  ?

=> to add a column to view  , the view must be recreated

 CREATE OR REPLACE VIEW CV2
 AS
 SELECT D.DNAME,SUM(E.SAL) AS TOTSAL,AVG(SAL) AS AVGSAL
 FROM EMP E INNER JOIN DEPT D
       ON E.DEPTNO = D.DEPTNO
 GROUP BY D.DNAME ;

28-oct-23 

 synonyms :- 
 -----------------

 => a synonym is another name or alterantive name for a table or view

 =>  if tablename is lengthy then we can give a simple and short name to the table
       called synonym, after creating synonym  instead of using tablename we can
       use synonym name in SELECT/INSERT/UPDATE/DELETE queries.

  syn :- CREATE SYNONYM <NAME> FOR <TABNAME> ;

 Granting permissions to create synonym :- 
 ---------------------------------------------------------

 SYSTEM :- 

 SQL>GRANT CREATE SYNONYM TO BATCH730;

Ex :- 

   SQL>CREATE SYNONYM E FOR EMP ; 

  after creating instead of using table name use synonym name in SELECT/INSERT/UPDATE/DELETE queries

 1   SELECT * FROM  E; 

 2   UPDATE E SET COMM = 500 WHERE EMPNO = 7369 ;

Question :- 
---------------

  1   CREATE SYNONYM E FOR EMP ;
 
  2   SELECT * FROM EMP  E ;
 
  3   RENAME EMP TO E ;

  difference between synonym and alias ?
 
         synonym			                  alias

1      permanent				not permanent

2      stored in db				not stored in db

3     scope of the synonym is			scope of the alias is 
       upto the schema 			upto the query

=> list of synonyms created by user ?

    SELECT SYNONYM_NAME,TABLE_NAME FROM USER_SYNONYMS ; 

Droping synonym :-
-----------------------

 DROP SYNONYM  E ;  


Accessing table without owner name :- 
-----------------------------------------------------

 BATCH730 :- 
 ------------------

 SQL>GRANT ALL ON EMP TO NARESH ;

 NARESH :- 
 ---------------

 SQL>SELECT * FROM BATCH730.EMP ;

  SQL>CREATE SYNONYM EMP FOR BATCH730.EMP;

 SQL>SELECT * FROM EMP ; 

SEQUENCES :-
---------------------

  =>  sequences are created to  generate sequence numbers.
  => used to auto increment column values.
  
 syn :- 

  CREATE SEQUENCE <NAME>
  [START WITH <VALUE>]
  [INCREMENT BY <VALUE>]
  [MAXVALUE <VALUE>]
  [MINVALUE <VALUE>]
  [CYCLE/NOCYCLE]
  [CACHE <SIZE>] ;

Ex :- 

   SQL>CREATE SEQUENCE S1
             START WITH 1 
             INCREMENT BY 1
             MAXVALUE 5 ; 
       
 using sequence :- 
 -----------------------

 CREATE TABLE STUDENT
 (
  SID   NUMBER(2),
  SNAME  VARCHAR2(10) 
 );

 INSERT INTO STUDENT VALUES (S1.NEXTVAL , 'A');
 INSERT INTO STUDENT VALUES (S1.NEXTVAL , 'B');
 INSERT INTO STUDENT VALUES (S1.NEXTVAL , 'C');
 INSERT INTO STUDENT VALUES (S1.NEXTVAL , 'D');
 INSERT INTO STUDENT VALUES (S1.NEXTVAL , 'E');
 INSERT INTO STUDENT VALUES (S1.NEXTVAL , 'F') ;  => ERROR


SELECT * FROM STUDENT ;

       SID	 SNAME
 ---------- 	----------
         1	 A
         2	 B
         3 	C
         4 	D
         5 	E

Ex 2 :-  calling sequence in update command

 CREATE SEQUENCE S2
 START WITH 100
 INCREMENT BY 1
 MAXVALUE 999 ; 

 => use above sequence to generate empno in emp table ?

    UPDATE EMP SET EMPNO = S2.NEXTVAL ; 

 Ex 3 :- 

  BILL
  BILLNO        	  BDATE       
  NIT/1023/1
  NIT/1023/2

 CREATE TABLE BILL
 (
  BILLNO   VARCHAR2(20) ,
  BDATE    TIMESTAMP 
 );

create sequence to generate billno :- 
 -----------------------------------------------

   CREATE SEQUENCE S3
   START WITH 1
   INCREMENT BY 1
   MAXVALUE 9999;

using sequence :-
------------------------

   INSERT INTO BILL VALUES ( 'NIT/'||TO_CHAR(SYSDATE,'MMYY')||'/'||S3.NEXTVAL,SYSDATE);



 SELECT * FROM BILL ;

BILLNO		BDATE

NIT/1023/1	28-OCT-23 08.45.16.000000 AM
NIT/1023/2	28-OCT-23 08.45.18.000000 AM
NIT/1023/3	28-OCT-23 08.45.18.000000 AM

30-oct-23 

 CYCLE/NOCYCLE :- 
 ----------------------------

 =>  by default sequence created with NOCYCLE

 => if sequence created with NOCYCLE then it starts from start with and
      generates upto max and after reaching max then it stops.

 => if sequence created with CYCLE then it starts from start with and
      generates upto max and after reaching max then it will reset to min.

  CREATE SEQUENCE S5
  START WITH 1
  INCREMENT BY 1
  MAXVALUE 5
  MINVALUE 1
  CYCLE
  CACHE 4 ;

CACHE size :- 
--------------------

  CREATE SEQUENCE S10
  START WITH 1
  INCREMENT BY 1
  MAXVALUE 1000
  MINVALUE 1
  CYCLE
  CACHE 100 ;
  
  =>  oracle preallocates next 100 values in cache memory  and whenever we 
        call seq.nextval then oracle goes to cache memory and return the 
        next value from cache memory and accessing cache memory is faster
        than accessing db, so this improves performance.

 =>  default cache size is 20 

 => cache size must be less than 1 cycle.

 Question :- 
 -------------------

  CREATE SEQUENCE S20
  START WITH 1
  INCREMENT BY 1
  MAXVALUE 10
  MINVALUE 1
  CYCLE ; 

=> above command returns error when executed what could be the reason ?

   ans :- cache size (20) more than the cycle (10)

 USER_SEQUENCES :- 
 --------------------------------

  => stores information about sequences created by user

      sql>create sequence s30 ;

    SELECT MIN_VALUE,
                   MAX_VALUE,
                   INCREMENT_BY,
                   CYCLE_FLAG,
                   CACHE_SIZE
    FROM USER_SEQUENCES 
    WHERE SEQUENCE_NAME='S30' ; 
  
  MIN_VALUE  MAX_VALUE  INCREMENT_BY C      CACHE_SIZE
---------- 	        ----------          ------------               -         ----------
         1 	       1.0000E+28     1                          N         20

Altering sequence parameters :- 
------------------------------------------

=> all sequence parameters can be altered except start with.

 SQL>ALTER SEQUENCE S30 MAXVALUE 10; 

 SQL> ALTER SEQUENCE S30 CYCLE ;  => ERROR => cache must be less than 1 cycle
 
 SQL> ALTER SEQUENCE S30 CACHE 5 ;

SQL> ALTER SEQUENCE S30 CYCLE ;

Droping sequence :- 
-----------------------------

 SQL>DROP SEQUENCE S1 ; 

IDENTITY :- 
-----------------
 
 => identity is also used to generate sequence numbers
 => introduced in 12c
 => used to auto increment column values

 ex :- 

  CREATE TABLE student
  (
   sid   NUMBER(3)  GENERATED ALWAYS AS IDENTiTY
                                ( START WITH 100 INCREMENT BY 1 MAXVALUE 999) ,
   sname VARCHAR2(10)
  );

 INSERT INTO student (sname) VALUES('A');
 INSERT INTO student (sname) VALUES('B');
 INSERT INTO student (sname) VALUES('C');

 SELECT * FROM STUDENT;
 
SID	SNAME
100	A
101	B
102	C

 difference between sequence & identity ?

 sequence is not bind to any column in any table but where as identity bind to
 a column in a table.

 
31-OCT-23 

Materialized views :- 
---------------------------

=> a Materialized view is also a db object that stores query result or precomputed result

 => Queries performs complex joins and group by operations on tables
       contains huge amount of data takes more time to run , so create
       M.view and store the output in m.view and whenever we want that
       output instead of running query on table run the query on m.view.

 => M.views are created for improving performance of queries performing
      complex joins and group by operations.

 => widely used in DWH (Data Warehouse).
 
 Syntax :- 

  CREATE MATERIALIZED VIEW <NAME>
  AS
  SELECT STATEMENT ; 

 Ex :- 

  CREATE MATERIALIZED VIEW MV1
  AS
  SELECT DEPTNO,SUM(SAL) AS TOTSAL
  FROM EMP 
  GROUP BY DEPTNO ;

 => oracle creates m.view "MV1" and stores query output  and whenever
      we want dept wise total sal then execute the following query.

      SELECT * FROM MV1 ; 

 Refreshing :- 
 -------------------

  => if base table data changes by default m.view is not updated and updating
       m.view is called refreshing m.view.

 => M.view can be refreshed in 3 ways 

     1  on demand (default)
     2  on commit
     3  on time interval

  on demand :- 
  ------------------

  => execute the following procedure to refresh m.view

      EXECUTE  DBMS_MVIEW.REFRESH(M.VIEW NAME);

 Ex :- 

 step 1 :-  update base table

  SQL>UPDATE EMP SET SAL = SAL + 1000;

 step 2 :- refresh m.view

  SQL>EXECUTE DBMS_MVIEW.REFRESH('MV1');

step 3 :- check

  SQL>SELECT * FROM MV1 ;
 
 on commit :- 
 -----------------

  => once changes made to base table are committed then m.view is refreshed
       automatically.

  CREATE MATERIALIZED VIEW MV2
  REFRESH ON COMMIT
  AS
  SELECT DEPTNO,SUM(SAL) AS TOTSAL
  FROM EMP 
  GROUP BY DEPTNO ;

   
STEP 1 :- update base table
 
 SQL>UPDATE EMP SET SAL = SAL - 1000 ; 

STEP 2 :- commit the changes
 
  SQL>COMMIT ; 

 STEP 3 :-  check m.view

 SQL>SELECT * FROM MV2 ;

    DEPTNO     TOTSAL
     ----------       ----------
        30            9400
        10            8750
        20           10875
 
 on time interval :- 
 -----------------------

  => refreshing m.view based on time intervals like every one week,one month etc

  CREATE MATERIALIZED VIEW MV3
  REFRESH FORCE
  START WITH SYSDATE NEXT SYSDATE + 7 
  AS
  SELECT DEPTNO,SUM(SAL) AS TOTSAL
  FROM EMP 
  GROUP BY DEPTNO ;
 
1-nov-23

 Refresh methods :- 
 --------------------------
 
 1  complete 
 2  fast
 3  force 

 complete :- 
 ---------------

1  existing data in m.view is truncated
2  oracle executes the query associated with m.view
3  data returned by query is inserted into m.view

 fast :- 
------------

 => in fast method  only changes are applied to m.view but it is not completely recreated
 => since last refresh whatever changes are made to table only those changes applied
      to m.view.
=>  to record changes we need to create m.view log

   SQL>CREATE MATERIALIZED VIEW LOG ON EMP ;

 force :- 
 -------------

  => here oracle uses either complete or fast method
  
 
=> list of m.views created by user ? 

     SELECT MVIEW_NAME FROM USER_MVIEWS ;

 Droping m.view :- 
 ------------------------
 
  SQL>DROP MATERIALIZED VIEW MV1 ; 

 INDEXES :- 
 -----------------

 =>  index is also a db object created to improve the performance of data accessing.

 => index in db is similar to index in textbook , In textbook using index a particular
      topic can be located fastly and in db using index a particular record can be 
      located fastly.

 => indexes created on columns and that column is called index key.

 => indexes created on columns 

    1  which are frequently used in where clause
    2  which are used in join operation

  Types of Indexes :- 
  --------------------------

  1  BTREE indexes
             simple
             composite
             unique
  2 BITMAP indexes 

 simple btree index :- 
 ---------------------------

 =>  if index created on single column then it is called simple index 

       CREATE  INDEX <NAME>  ON <TABNAME> (COLNAME) ;

  Ex :- 

    SQL>CREATE INDEX I1 ON EMP(SAL);

 EMP				       3000
 SAL 
 3000
 1000
 2000			   2000			4000
 4000
 1500		1000 *                     2500 *	       4000 *	5000 *
 3000		1500 *	              3000 *,*
 5000		 2000 *
 2500

 => when we submit query to oracle , it uses following methods to locate the record

  1   TABLE SCAN
  2   INDEX SCAN

=> in table scan oracle scans complete table to locate the record

=> in index scan on avg oracle scans only half of the table to locate the record , so
     index scan is faster than table scan.

    SELECT * FROM EMP WHERE SAL = 3000 ;   (INDEX)
    SELECT * FROM EMP WHERE SAL >= 3000 ; (INDEX)
    SELECT * FROM EMP WHERE SAL <= 3000 ; (INDEX)

    SELECT * FROM EMP ;                                                (TABLE)
    SELECT * FROM EMP WHERE ENAME='BLAKE' ;  (TABLE)
     
 command to see the execution plan :- 
 -------------------------------------------------

 SQL>SET AUTOTRACE ON EXPLAIN ;

 composite index :- 
 -------------------------

 => if index created on multiple columns then index is called composite index 

     CREATE INDEX I2 ON EMP (DEPTNO,JOB) ;

		                        20

                                 10                                                 30
	
                 10 clerk *	         20 clerk *,*         30 clerk *
                 10 mgr *	         20 mgr *             30 mgr *
                                                                       30 salesman *,*,*,*
 
 => oracle uses above index when where cond based on leading column of the index
      i.e. deptno 

       SELECT * FROM EMP WHERE DEPTNO = 20 ;          (INDEX)
       SELECT * FROM EMP WHERE DEPTNO = 20 AND JOB='CLERK' ;  (INDEX)
      
       SELECT * FROM EMP WHERE JOB='CLERK'   ;   (TABLE)

unique index :- 
----------------------

 => unique index doesn't allow duplicate values into the column on which index is created

      ex :-   CREATE  UNIQUE INDEX  I3 ON EMP(ENAME) ;

 			            K

		    G		                      Q	
	
	 ADAMS *              JAMES *            MARTIN *             SCOTT *
                  ALLEN *                JONES *            MILLER *              SMITH *
                  BLAKE *                                                                         WARD * 
	

      1         SELECT * FROM EMP WHERE ENAME = 'BLAKE' ; 
      2         INSERT INTO EMP(EMPNO,ENAME,SAL) VALUES(556,'BLAKE',4000); => ERROR

   what are the different methods to enforce uniqueness ?

  1  declare primary key / unique constraint
  2  create unique index 

  => primary key / unique columns are implicitly indexed by oracle and oracle creates
       a unique index on primary key / unique columns and unique index doesn't allow
       duplicates , so primary key / unique also doesn't allow duplicates.

 BITMAP indexes :- 
 --------------------------

 => bitmap indexes are created on low cardinality columns i.e. column that contains 
      less distinct values.

   ex :-   job,deptno,gender

 => bitmap index stores bits (1,0)

 SQL>CREATE BITMAP  INDEX  BI2 ON EMP(JOB);

BI1(GENDER)	EMP			BI2(JOB)
M	F	GENDER	JOB		ANALYST	   CLERK	  MGR	
1	0	M	CLERK		0	   1	  0
0	1	F	MGR                         0	   0  	  1
1	0	M	ANALYST		1	   0	  0
0	1	F	CLERK		0	   1	  0
1	0	M	MGR		0	   0	  1
1	0	M	ANALYST	    	1	   0	  0 

SELECT * FROM EMP WHERE GENDER='M' ; 

 for the above query oracle goes to index BI1 and search for the records , if  M=1
 then corresponding records selected from table ,if M=0 record is not selected.
 here bit comparision is faster than value comparision.

 03-NOV-23

  => difference between btree & bitmap indexes ?

	     BTREE			BITMAP
 
 1  recommended on high cardinality	                recommended on low
     columns ex :- accno			cardinality columns ex :- actype

 2  stores values 				stores bits 

 3  stores rowids				doesn't store rowids

 => list of indexes created on emp  ?

 SQL> COLUMN INDEX_NAME FORMAT A20
 
 SQL> SELECT INDEX_NAME,INDEX_TYPE
           FROM USER_INDEXES
           WHERE TABLE_NAME='EMP' ; 

   Droping index :- 
   ---------------------

  SQL>DROP INDEX I1 ;   

  if we drop table what about indexes created on table ?

  ans :-  indexes are also dropped

Question :-

 SQL> DROP TABLE products;

What is the implication of this command? (Choose all that apply.)

A. All data along with the table structure is deleted.          T
B. The pending transaction in the session is committed.   T
C. All indexes on the table will remain but they are invalidated.  F
D. All views and synonyms will remain but they are invalidated. T
E. All data in the table are deleted but the table structure will remain.  F

CLUSTER :- 
-----------------

  => a cluster is also a db object that stores data related to two or more tables in a 
       single disk space.

  => cluster improves performance of join operation 

  => tables which are frequently joined  better to cluster those tables 

  => follow below steps to cluster tables 

 1  create cluster
 2  create index on cluster
 3  create tables

 creating cluster :-  
 ----------------------
 
  CREATE CLUSTER C1 (D   NUMBER(2));

 creating index on cluster :- 
 -------------------------------------

  CREATE INDEX CI10  ON CLUSTER C1 ; 

 creating tables :-  
 -----------------------

 CREATE TABLE DEPT77
 (
  DNO  NUMBER(2) PRIMARY KEY,
  DNAME VARCHAR2(10) 
 )  
 CLUSTER C1 (DNO) ; 

 INSERT INTO DEPT77 VALUES(10,'HR');
 INSERT INTO DEPT77 VALUES(20,'IT');

 CREATE TABLE EMP77
 ( 
  ENO  NUMBER(4) PRIMARY KEY,
  ENAME VARCHAR2(10) NOT NULL,
  DNO   NUMBER(2)  REFERENCES DEPT77(DNO)
 )
 CLUSTER C1(DNO) ; 

 INSERT INTO EMP77 VALUES(1,'A',10);
 INSERT INTO EMP77 VALUES(2,'B',20);

 => both tables data stored in cluster c1 and organized based on dno 

Droping cluster :- 
-----------------------
 
SQL>DROP CLUSTER C1 ;   => ERROR

SQL>DROP CLUSTER C1 INCLUDING TABLES ;  

 => list of tables grouped in cluster c1 ? 

    SELECT TABLE_NAME
    FROM USER_TABLES
    WHERE CLUSTER_NAME='C1' ; 

 ==============================================================

04-nov-23			 PL/SQL 
			 ======		

			PL => procedural language
		   

			            ORACLE

		non-procedural		procedural
 
		SQL			PL/SQL


 Features :- 
 ---------------

1  improves performance :- 
    ---------------------------------

  => in pl/sql ,  sql commands can be grouped into one block and we submit that
       block to oracle and oracle executes that block and gives response , so
       in pl/sql no of requests and response between user and oracle are reduced
       and performance is improved.
 
 2   supports conditional statements :- 
     ------------------------------------------------

  => pl/sql supports conditional statements like IF-THEN-ELSE  ,  with the help of
       conditional statements we can execute sql commands based on conditions.
 
 3 supports loops :- 
   -------------------------

 => loops are used to execute statements repeatedly multiple times and pl/sql
      supports looping statements like WHILE,FOR etc.
 
 4  supports error handling :- 
   -----------------------------------

  => in pl/sql , if any statement causes error then we can handle that error
       and we can display our own simple and user friendly message.

 5  supports reusability :- 
  -------------------------------

  => pl/sql programs can be stored in db and applications which are connected
       to db can reuse pl/sql programs.
 
6  supports modular programming :- 
 ------------------------------------------------
 
 => In pl/sql  a big program can be divided into small modules 

Basic programming
conditional statements
loops
cursors
collections
error handling
procedures
functions
packages
triggers
dynamic sql
working with files
working with binary data 

 => pl/sql blocks are 2 types 

   1  Anonymous block
   2  Named blocks
                 procedures
                 functions
                 packages
                 triggers 

 Anonymous Blocks :- 
------------------------------

=> a pl/sql block without name is called anonymous block

  DECLARE
        declaration-part;     optional
  BEGIN
       execution-part;
  END;
     /       =>  compile  & run 

 How to print messages :- 
 ----------------------------------

  DBMS_OUTPUT.PUT_LINE(message);
  ---------------------  ---------------
     package	procedure

 => by default messages are not send to output ,  to send messages to output 
      execute the following command 
 
     SQL>SET SERVEROUTPUT ON 
 
How to write pl/sql program :-
----------------------------------------
 
1 Editor
2 IDEs (integrated developmen environment)

 	 	EDITOR		IDE
 
 coding		yes		yes

 compilation	no		yes

 execution		no		yes

debugging	no		yes

example		NOTEPAD	SQL DEVELOPER

using NOTEPAD :- 
--------------------------

 => open notepad and enter following code

 BEGIN
    DBMS_OUTPUT.PUT_LINE('HELLO WELCOME');
 END;
  /

 => save the program is a file as D:\PLSQL\"PROG1.SQL"

 => go to sqlplus compile and run the program as follows

   SQL>@D:\PLSQL\PROG1.SQL

   output :-	 HELLO WELCOME

06-NOV-23

Datatypes in PL/SQL :- 
--------------------------------

1  scalar types or built-in types
2  user defined types
3  reference types 

scalar types or built-in types :- 
-----------------------------------------

1  NUMBER(P) / NUMBER(P,S)
2  CHAR/VARCHAR2/LONG/CLOB
3  NCHAR/NVARCHAR2/NCLOB
4  DATE/TIMESTAMP
5  BFILE / BLOB 
6  BINARY_FLOAT / BINARY_DOUBLE 
7  BINARY_INTEGER / PLS_INTEGER
8  BOOLEAN
 
   1 TO 6    =>  allowed in SQL, PL/SQL
    7,8         =>  allowed only in PL/SQL but not allowed in SQL.

Declaring variables :- 
-----------------------------

       variablename       datatype(size) ;

 ex :- 

       X     NUMBER(2);
       S     VARCHAR2(10);
       D     DATE;
       B     BOOLEAN;

 Assigning values to variables :-
 ------------------------------------------

      variablename  :=   value  ;             :=    => assignment operator

ex :- 

    X   := 100;
    S   :=  'abc';
    D   :=  SYSDATE;
    B   :=   TRUE; 

Example :- 

 => write a prog to add two numbers ?

     DECLARE
         a   NUMBER(3);
         b   NUMBER(3);
         c   NUMBER(4);
    BEGIN
        a := 100;
        b := 200;
        c := a+b;
        DBMS_OUTPUT.PUT_LINE(c);
   END;
       /

 output :-  300

How to input values at runtime :-
-------------------------------------------

=> to input values at runtime use variables prefixed with "&"

ex  :-           1         a  :=  &a;

                  enter value for a :- 100

                           a  := 100;

                  2       a   :=  &x; 

                     enter value for x :-  100

                          a :=  100;

    DECLARE
         a   NUMBER(3);
         b   NUMBER(3);
         c   NUMBER(4);
    BEGIN
        a := &a;
        b := &b;
        c := a+b;
        DBMS_OUTPUT.PUT_LINE(c);
   END;
       /

input :- 

Enter value for a: 500
old   6:         a := &a;
new   6:         a := 500;
Enter value for b: 300
old   7:         b := &b;
new   7:         b := 300;

output :-   800

VERIFY :- 
-------------

 SET VERIFY OFF  => will not display old & new stmts
 SET VERIFY ON    => displays old & new statements

=> write a prog to input date and print day of the week ?

    DECLARE
      d   DATE;
   BEGIN
       d := '&date';
       DBMS_OUTPUT.PUT_LINE(TO_CHAR(d,'day'));
  END;
      /
 
input :- 

 Enter value for date: 6-NOV-23

output :-  monday

 => write a prog to input name and print first name ,middle name and last name ?


      SUBSTR(string,start,[len])
      INSTR(string,char,[start,occurance])

    DECLARE
           n    VARCHAR(30);
           f     VARCHAR(20);
           m   VARCHAR(20);
           l      VARCHAR(20);
   BEGIN
          n := '&name';
          f  := SUBSTR(n,1,INSTR(n,' ')-1);
          l  := SUBSTR(n,INSTR(n,' ',1,2)+1);
         m :=    TRIM(LTRIM(RTRIM(n,l),f));
         DBMS_OUTPUT.PUT_LINE(' First Name  =  '||f);
         DBMS_OUTPUT.PUT_LINE(' Middle Name  =  '||m);
         DBMS_OUTPUT.PUT_LINE(' Last Name  =  '||l);
   END;
       /
       
    input :-  sachin ramesh tendulkar
    
     output :- 

    First Name :-  sachin
    Middle Name :- ramesh
    Last Name   :- tendulkar
 
07-nov-23

 Regular expression functions :-
 ------------------------------------------

  1  REGEXP_COUNT
  2  REGEXP_SUBSTR
  3  REGEXP_INSTR
  4  REGEXP_REPLACE
  5  REGEXP_LIKE

 REGEXP_SUBSTR :-
--------------------------------

  REGEXP_SUBSTR(string,pattern,start,occurance)

 ex :- 
 
REGEXP_SUBSTR('abc123xyz456','[0-9]+')         =>  123
REGEXP_SUBSTR('abc123xyz456','[0-9]+',1,2)   =>  456
REGEXP_SUBSTR('abc123xyz456','[a-z]+',1,2)   =>  xyz

REGEXP_SUBSTR('sachin ramesh tendulkar','[a-z]+')  => sachin
REGEXP_SUBSTR('sachin ramesh tendulkar','[a-z]+',1,2)  => ramesh
REGEXP_SUBSTR('sachin ramesh tendulkar','[a-z]+',1,3) => tendulkar

  DECLARE
           n    VARCHAR(30);
           f     VARCHAR(20);
           m   VARCHAR(20);
           l      VARCHAR(20);
   BEGIN
          n   := '&name';
          f    :=  REGEXP_SUBSTR(n,'[a-z]+',1,1);
          m  :=  REGEXP_SUBSTR(n,'[a-z]+',1,2);
          l    :=  REGEXP_SUBSTR(n,'[a-z]+',1,3);
         DBMS_OUTPUT.PUT_LINE(' First Name  =  '||f);
         DBMS_OUTPUT.PUT_LINE(' Middle Name  =  '||m);
         DBMS_OUTPUT.PUT_LINE(' Last Name  =  '||l);
   END;
       /

DB programming with PL/SQL :- 
--------------------------------------------
 
 => To perform operations on db  execute sql commands from pl/sql program
 => the following commands can be executed from pl/sql program

  1  DML (insert,update,delete)
  2  DQL (select)
  3  TCL  (commit,rollback,savepoint)

 SELECT stmt syntax :- 
 ------------------------------

 SELECT col1 , col2   INTO  var1,var2
 FROM tabname
 WHERE cond ; 

ex :- 

 SELECT ename,sal INTO x,y
 FROM emp 
 WHERE empno = 7844;

ex 1 :- 

 => write a prog to input empno and print name & salary ?

   DECLARE
       vempno       NUMBER(4);
       vename      VARCHAR2(10);
       vsal             NUMBER(7,2); 
  BEGIN
       vempno := &empno;
       SELECT ename,sal INTO vename,vsal
       FROM emp 
       WHERE empno = vempno;
       DBMS_OUTPUT.PUT_LINE('Name = '||vename);
       DBMS_OUTPUT.PUT_LINE('Sal ='||vsal);
   END;
      /

input :-

  Enter value for empno: 7844

output :- 
 
Name = TURNER
Sal     =  1500

=> write a prog to input empno and calculate experience of the employee ?

   DECLARE
      veno          NUMBER(4);
      vhire          DATE;
      vexpr         NUMBER(2);
   BEGIN
      veno := &empno;
      SELECT hiredate INTO vhire
      FROM emp 
      WHERE empno = veno;
      vexpr := (SYSDATE - vhire)/365;
      DBMS_OUTPUT.PUT_LINE('Experience = '||vexpr||' years');
  END;
    /
      
 INPUT :- 
 ------------
Enter value for empno: 7844
 
OUTPUT :- 
---------------

Experience = 42 years

 DECLARE
      veno          NUMBER(4);
      vhire          DATE;
      vexpr         NUMBER(2);
   BEGIN
      veno := &empno;
      SELECT hiredate INTO vhire
      FROM emp 
      WHERE empno = veno;
      vexpr := (SYSDATE - vhire)/365;
      DBMS_OUTPUT.PUT_LINE('Experience = '||vexpr||' years');
  END;
    /

  conditional statements :- 
  --------------------------------

 1  IF-THEN-ELSE
 2  Multi IF
 3  Nested IF

IF-THEN-ELSE :- 
-----------------------

   IF  COND  THEN
         statements;
   ELSE
         statements;
   END IF;

Multi IF :-
----------------

  IF  cond1 THEN
      statements;
  ELSIF cond2 THEN
      statements;
  ELSIF  cond3 THEN
      statements;
  ELSE
      statements;
  END IF;

Nested IF :- 
----------------

 IF  COND  THEN
    IF  COND THEN
         statements;
    ELSE
         statements;
   END IF;
ELSE
    statements;
END IF;

08-nov-23 

=> write a prog to input empno and increment sal by specifi amount after
      increment if sal exceeds 5000 then cancel that increment ?

     DECLARE
           veno    NUMBER(4);
           vamt    NUMBER(5);
           vsal     NUMBER(7,2);
      BEGIN
           veno := &empno;   
           vamt := &amount;   
           UPDATE emp SET sal = sal + vamt WHERE empno = veno; 
           SELECT sal INTO vsal FROM emp WHERE empno = veno;
           IF vsal > 5000 THEN
               ROLLBACK;
           ELSE
              COMMIT;
          END IF;
     END;
          /

input :- 
 
Enter value for empno: 7788
Enter value for amount: 1000

output :- 

 pl/sql procedure successfully completed

=> write a prog to input empno and increment sal as follows ?

    if  deptno =10  incr  sal by 10%
                      20                     15%
                      30                      20%
                    others                  5%

  DECLARE
       veno   NUMBER(4);
       vdno   NUMBER(2);
       vpct    NUMBER(2);
 BEGIN
      veno := &empno;
      SELECT deptno INTO vdno FROM emp WHERE empno = veno;
      IF vdno = 10 THEN
         vpct := 10;
     ELSIF vdno=20 THEN
         vpct := 15;
     ELSIF vdno=30 THEN
        vpct := 20;
    ELSE
        vpct := 5;
     END IF;
      UPDATE emp SET sal = sal + (sal*vpct/100) WHERE empno = veno;
      COMMIT;
    END;
        /

 => write a prog to process bank transaction (w/d)  ? 

 ACCOUNTS
 ACCNO	ACTYPE	BAL 
 100	S	10000
 101	C	20000

 DECLARE
     vacno      NUMBER(4);
     vtype       CHAR(1);
     vamt        NUMBER(5);
     vbal         NUMBER(8);
 BEGIN
      vacno   := &acno;
      vtype    := '&type';  
      vamt    :=  &amount;
      IF vtype='w'  THEN
         SELECT bal INTO vbal FROM accounts WHERE accno = vacno;
         IF  vamt > vbal THEN
            DBMS_OUTPUT.PUT_LINE('insufficient balance');
         ELSE
            UPDATE accounts SET bal = bal - vamt WHERE accno = vacno;
         END IF;
      ELSIF vtype='d' THEN
           UPDATE accounts SET bal = bal + vamt WHERE accno = vacno;
     ELSE
           DBMS_OUTPUT.PUT_LINE('invalid transaction type');
     END IF;
     COMMIT;
 END;
   /

input :- 

Enter value for acno: 100
Enter value for type: w
Enter value for amount: 1000

=> write a prog to process money transfer ?

    DECLARE
       vsacno      NUMBER(4);
       vtacno       NUMBER(4);
       vamt          NUMBER(5);
       vbal           NUMBER(8);
  BEGIN
       vsacno := &sacno;
       vtacno  := &tacno;
       vamt    := &amount;
       SELECT bal INTO vbal FROM accounts WHERE accno = vsacno; 
       IF vamt  > vbal THEN
            DBMS_OUTPUT.PUT_LINE('insufficient balance');
       ELSE
            UPDATE accounts SET bal = bal - vamt WHERE accno = vsacno;
            UPDATE accounts SET bal = bal + vamt WHERE accno = vtacno;
            COMMIT;
       END IF;
  END;
  /

09-nov-23

 => write a prog to input sno and calculate total , avg,result and insert into 
     result table ?

  STUDENT
  SNO	SNAME	S1    S2    S3
  1	A	80    90     70
  2	B	30    60     50

  RESULT
  SNO	STOTAL	SAVG	SRES 

 DECLARE
   vsno   NUMBER(2);
   vs1     NUMBER(3);
   vs2     NUMBER(3);
   vs3     NUMBER(3);
   vtotal  NUMBER(3);
   vavg   NUMBER(5,2);
   vres    CHAR(4);
 BEGIN
    vsno := &sno;
    SELECT s1,s2,s3 INTO vs1,vs2,vs3 FROM student WHERE sno = vsno;
    vtotal := vs1 + vs2 + vs3 ;
    vavg :=  vtotal/3;
    IF vs1>=35 AND vs2>=35 AND vs3>=35 THEN
        vres := 'PASS';
   ELSE
        vres := 'FAIL';
   END IF;
   INSERT INTO result VALUES(vsno,vtotal,vavg,vres);
   COMMIT;
 END;
   /

Reference Types :- 
-------------------------

1  %TYPE
2  %ROWTYPE

%TYPE :- 
-------------

  => used to refer  column datatype.
  => using %TYPE we can match variable type with column type.

   ex :-   vename     emp.ename%TYPE;
             vsal           emp.sal%TYPE;

  => whatever datatype & size declared for sal column the same type & size
       assigned to variable  " vsal " 

 => advantage of %TYPE is even if column type or size changes PL/SQL program
      is not affected , so this reduces complexity.

%ROWTYPE :- 
----------------------

 => used to refer row type
=> using %ROWTYPE we can match variable type with record type.

  ex  :-   r     emp%ROWTYPE;

 =>  a row from emp table can be assigned to variable "r" 

      SELECT * INTO r FROM emp WHERE empno = 7844;

      r
      empno  ename  job            hiredate  mgr  sal       comm   deptno
      7844    turner   salesman                          1500    0           30

      r.sal  => 1500
      r.ename => turner

 => %ROWTYPE reduces no of variables required in the program and reduces
      complexity.

 EX :- 

  
  STUDENT
  SNO	SNAME	S1    S2    S3
  1	A	80    90     70
  2	B	30    60     50

  RESULT
  SNO	STOTAL	SAVG	SRES 

 DECLARE
   vsno  student.sno%TYPE;
   s        student%ROWTYPE;
   r        result%ROWTYPE;
 BEGIN
   vsno := &sno;
   SELECT * INTO s FROM student WHERE sno = vsno; 
   r.stotal := s.s1 + s.s2 + s.s3 ;
   r.savg  :=  r.stotal/3;
   IF s.s1>=35 AND s.s2>=35 AND s.s3>=35 THEN
        r.sres := 'pass';
    ELSE
       r.sres := 'fail';
   END IF;
   INSERT INTO result VALUES(vsno,r.stotal,r.savg,r.sres);
   COMMIT;
 END;
 /

s
sno  sname  s1  s 2  s3
1     A           80  90   70

r
sno   stotal   savg  sres
         240      80     pass
 
Loops IN PL/SQL :- 
--------------------------

1  simple loop
2  while loop
3  for loop

simple loop :- 
------------------

LOOP
   statements;
   EXIT WHEN COND;
END LOOP;

if cond = false loop continues
if cond = true loop terminates

while loop :-
--------------

WHILE(cond)
LOOP
   statements;
END LOOP;

if cond = true loop continues
if cond = false loop terminates 

FOR loop :- 
----------------

  FOR  var  IN  low..upp
  LOOP
    statements;
  END LOOP;

  FOR  x  IN 1..10
  LOOP
    statements;
 END LOOP;

=> loop variable "x"  declared implicitly as number type
=> by default "x" is increment by 1
=> "x" is read only variable
=> scope of "x" is upto the for loop

10-nov-23 

 => write a prog to print numbers from 1 to 20 ? 

  using simple loop :- 
  --------------------------

   DECLARE
       x     NUMBER(2) := 1;
   BEGIN
       LOOP
          DBMS_OUTPUT.PUT_LINE(x);
          x := x+1;
          EXIT WHEN x > 20;
      END LOOP;
   END;
      /

 using while loop :-  
--------------------------

  DECLARE
       x     NUMBER(2) := 1;
   BEGIN
      WHILE(x<=20)
      LOOP
            DBMS_OUTPUT.PUT_LINE(x);
            x := x+1;
      END LOOP;
  END;
     /

using FOR loop :- 
------------------------

BEGIN
  FOR x  IN 1..20
LOOP
    DBMS_OUTPUT.PUT_LINE(x);
END LOOP;
END;
 /

REVERSE for loop :- 
----------------------------
 
BEGIN
  FOR x  IN REVERSE 1..20
LOOP
    DBMS_OUTPUT.PUT_LINE(x);
END LOOP;
END;
 /

=> write a prog to print 2024 calendar ? 

   01-JAN-2024 	?
   02-JAN-2024	?

  31-DEC-2024	?

  DECLARE
      d1       DATE;	
      d2       DATE;
 BEGIN
      d1 :=  '01-JAN-2024';
      d2 :=  '31-DEC-2024';
      WHILE(d1<=d2)
      LOOP
          DBMS_OUTPUT.PUT_LINE(d1||'      '||TO_CHAR(d1,'day'));
          d1 := d1 + 1;
     END LOOP;
  END;
     /

=> write a prog to print sundays between two given dates ?   

   DECLARE
      d1       DATE;	
      d2       DATE;
   BEGIN
      d1 :=  '01-JAN-2024';
      d2 :=  '31-DEC-2024';
      d1 :=  NEXT_DAY(d1,'SUNDAY');
      WHILE(d1<=d2)
      LOOP
            DBMS_OUTPUT.PUT_LINE(d1||'      '||TO_CHAR(d1,'day'));
            d1 := d1 + 7;
     END LOOP;
  END;
     /

 => write a prog to input string and print following pattern ? 
 
      input :-   NARESH

     output :- 

     N
     A
     R
     E
     S
     H

  DECLARE
     s     VARCHAR2(20);
  BEGIN
       s :=  '&string';
       FOR x IN 1..LENGTH(s)
       LOOP
            DBMS_OUTPUT.PUT_LINE(SUBSTR(s,x,1));
      END LOOP;
 END;
   /

=> write a prog to input string and print following pattern ?
 
     INPUT :-  NARESH

    OUTPUT :- 

  N
  NA
  NAR
  NARE
  NARES
  NAERSH

DECLARE
     s     VARCHAR2(20);
  BEGIN
       s :=  '&string';
       FOR x IN 1..LENGTH(s)
       LOOP
            DBMS_OUTPUT.PUT_LINE(SUBSTR(s,1,x));
      END LOOP;
 END;
   /

=> write a prog to input string and print reverse ?

       input :-  NARESH

       output :-  HSERAN 

    DECLARE
     s1     VARCHAR2(20);
     s2    VARCHAR2(20);
   BEGIN
       s1 :=  '&string';
       FOR x IN 1..LENGTH(s1)
       LOOP
           s2 :=  s2||SUBSTR(s1,-x,1);
       END LOOP;
       DBMS_OUTPUT.PUT_LINE(s2);
       IF  s1 = s2  THEN
            DBMS_OUTPUT.PUT_LINE('palindrome');
       ELSE
            DBMS_OUTPUT.PUT_LINE('not a palindrome');
       END IF;
   END ;
    / 

11-nov-23

CURSORS :- 
-------------------

 => cursors are used to  process multiple records in pl/sql program.
 => using cursors we can access row-by-row into pl/sql program.
 => from pl/sql prog  if we submit a query to oracle , it goes to db 
      and gets the data and copies that data into temporary memory
      called cursor 
=> in pl/sql prog we can give name to the cursor and access row-by-row
     into pl/sql prog and process the row.
=> follow below steps to use cursor

   1  declare cursor
   2  open cursor
   3  fetch records from cursor
   4  close cursor

Declaring cursor :- 
-----------------------

 CURSOR <name> IS SELECT STATEMENT ; 

 Ex :- 

 CURSOR C1 IS SELECT  ENAME,SAL FROM EMP ;

 Opening cursor :- 
 ----------------------

      OPEN  C1 ; 

  1  select stmt declared with cursor submitted to oracle
  2  oracle executes the query and data returned by query is copied to cursor
  3  c1 points to cursor

Fetching records from cursor :- 
------------------------------------------

 => "FETCH" statement is used to fetch record from cursor.

   syn :-   FETCH <cursor-name> INTO <variables>;
 
  ex :-    

        FETCH C1 INTO  vename,vsal;

 => fetch stmt fetches one row at a time but to process multiple rows 
      fetch stmt should be executed multiple times , so fetch stmt
      should be in a loop.

 Closing cursor :- 
 -----------------------

               CLOSE <cursor-name> ;

     EX :-   CLOSE C1 ;

cursor attributes :- 
------------------------
 
 %FOUND :- 
 -----------------

 TRUE          =>  if fetch is successful
 FALSE        =>  if fetch is unsuccessful

 %NOTFOUND :- 
 -----------------------

  TRUE         =>  if fetch unsuccessful
  FALSE       =>  if fetch successful

 %ROWCOUNT :- 
 ------------------------

   => returns no of rows fetched successfully

%ISOPEN :- 
----------------

 TRUE   => if cursor is opened
 FALSE  => if cursor is not opened

C1%FOUND
C1%NOTFOUND
C1%ROWCOUNT
C1%ISOPEN

=> write a prog to print all employee names and salaries ? 

  DECLARE
       CURSOR C1 IS SELECT ename,sal FROM emp ;
       vename  emp.ename%TYPE;
       vsal        emp.sal%TYPE;
  BEGIN
      OPEN C1;
 LOOP
     FETCH C1 INTO 	vename,vsal;
     EXIT WHEN C1%NOTFOUND;
     DBMS_OUTPUT.PUT_LINE(vename||'  '||vsal);
END LOOP;
     CLOSE C1;
 END;
 /
 
using while loop :- 
------------------------

  DECLARE
       CURSOR C1 IS SELECT ename,sal FROM emp ;
       vename  emp.ename%TYPE;
       vsal        emp.sal%TYPE;
  BEGIN
      OPEN C1;
      FETCH C1 INTO vename,vsal;
      WHILE(C1%FOUND)
 LOOP
     DBMS_OUTPUT.PUT_LINE(vename||'  '||vsal);
     FETCH C1 INTO vename,vsal;
END LOOP;
     CLOSE C1;
 END;
 /

FOR LOOP CURSOR / CURSOR FOR LOOP :- 
----------------------------------------------------------------

 FOR <var> IN <cursor-name>
 LOOP
    statements;
 END LOOP; 

 ex :- 

 FOR r IN C1
 LOOP
    statements;
 END LOOP;

 => Adv of FOR loop cursor is opening cursor,fetching records from cursor and
      closing cursor operations are performed implicitly.

 => for loop is executed no of times depends on no of rows in cursor.

 => everytime for loop executes a record is fetched from cursor and assigned to
      variable "r". 

 => loop variable "r" is also declared implicitly as rowtype.

  DECLARE
      CURSOR C1 IS SELECT ename,sal FROM emp;
  BEGIN
      FOR r IN C1
  LOOP
      DBMS_OUTPUT.PUT_LINE(r.ename||'  '||r.sal);
  END LOOP;
  END;
     /

13-NOV-23

INLINE CURSOR :- 
--------------------------

=>  cursor in for loop is called INLINE cursor.
 
BEGIN
 FOR r IN (SELECT ename,sal FROM emp)
LOOP
   DBMS_OUTPUT.PUT_LINE(r.ename||' ' ||r.sal);
END LOOP;
END;
 /

=> write a prog to calculate total sal without using sum function ?

 DECLARE
      t  NUMBER := 0;
 BEGIN
    FOR r IN (SELECT sal FROM emp)
   LOOP
         t :=  t + r.sal;
   END LOOP;
   DBMS_OUTPUT.PUT_LINE(t);
 END;
  /

=> write a prog to find max sal without using max function ? 

    DECLARE
          m   NUMBER := 0;
    BEGIN
        FOR r  IN (SELECT sal FROM emp)
     LOOP
          IF r.sal > m THEN
              m := r.sal;
          END IF;
    END LOOP;
    DBMS_OUTPUT.PUT_LINE(m);
   END;
    /


  DECLARE 
     CURSOR C1 IS SELECT sal FROM emp ORDER BY sal DESC ;
     vsal   emp.sal%TYPE;
  BEGIN
     OPEN C1;
     FETCH C1 INTO vsal;
     DBMS_OUTPUT.PUT_LINE(vsal);
     CLOSE C1;
  END;
   /

Assignment :- 
------------------

  => write a prog to print min salaary ? 


=> write a prog to calculate all the students total ,avg,result and insert into result table ?

  STUDENT
  SNO	SNAME	S1    S2    S3
  1	A	80    90     70
  2	B	30    60     50

  RESULT
  SNO	STOTAL	SAVG	SRES 

  DECLARE
    r   RESULT%ROWTYPE;
  BEGIN
    FOR s  IN (SELECT  sno,s1,s2,s3 FROM student)
   LOOP
         r.stotal :=  s.s1 + s.s2 + s.s3;
         r.savg  :=  r.stotal/3;
         IF s.s1>=35  AND s.s2>=35 AND s.s3>=35 THEN
               r.sres := 'pass';
         ELSE
              r.sres := 'fail';
         END IF;
         INSERT INTO result VALUES(s.sno,r.stotal,r.savg,r.sres);
     END LOOP;
     COMMIT;
     END;
         /

=> write a prog to print dept details along with emp details ? 

 BEGIN
   FOR  d  IN (SELECT deptno,dname FROM dept)
  LOOP
      DBMS_OUTPUT.PUT_LINE(d.deptno||'      '||d.dname);
      FOR e IN (SELECT empno,ename,sal FROM emp WHERE deptno = d.deptno)
     LOOP
         DBMS_OUTPUT.PUT_LINE(e.empno||'   '||e.ename||'   '||e.sal);
     END LOOP;
 END LOOP;
END;
  / 

REF CURSOR OR DYNAMIC CURSOR :- 
-------------------------------------------------------

 => a cursor acts like a constant because select stmt declared with cursor cannot be changed
      during program execution but refcursor acts like a variable because select stmt
      can be changed during program execution.

 => a cursor is called static but ref cursor is called dynamic

 Declaring ref cursor :- 
 ---------------------------

       C1        SYS_REFCURSOR;

Assigning data to cursor :-
---------------------------------

        OPEN  C1 ;     => ERROR

        OPEN C1  FOR SELECT  ename,sal FROM emp ;

       
        CLOSE C1;
 
        OPEN C1 FOR SELECT deptno,dname FROM dept;


        CLOSE C1 ;

14-NOV-23 

  DECLARE
    C1  SYS_REFCURSOR;
    e    emp%rowtype;
 BEGIN
      OPEN C1 FOR SELECT * FROM emp ;
   LOOP
      FETCH C1 INTO e;
      EXIT WHEN C1%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE(e.empno||'  '||e.ename||'   '||e.sal);
  END LOOP;
      CLOSE C1;
  END;
    /

 difference between cursor & ref cursor  ?

               CURSOR                                   	  REF CURSOR 

1     acts like a constant		acts like a variable

2    select stmt cannot		select stmt can
      be changed during		be changed 
      program execution                              during program execution

3   static				dynamic

4   select stmt assigned to		select stmt assigned to cursor
     cursor at the time of 		at the time of opening
     declaration

5  cannot be used as		can be used as 
    proc/func parameters 		proc/func parameter

Implicit cursor :- 
--------------------- 

 =>  cursor declared by oracle is called implicit cursor
 => implicit cursors are used to process dml statements
 => name of the implicit cursor is SQL
 => implicit cursor is created immediately after executing of dml command

attributes :- 
---------------

 %FOUND :- 
 ---------------

  TRUE     => if last dml is successful
  FALSE    => if last dml is unsuccessful

 %NOTFOUND :- 
 -----------------------

  TRUE     => if last dml is unsuccessful
  FALSE    => if last dml is  successful

%ROWCOUNT :- 
 ----------------------

  => returns no of rows affected by last dml

 SQL%FOUND
 SQL%NOTFOUND
 SQL%ROWCOUNT


Ex :- 

 DECLARE
     veno    emp.empno%TYPE;
 BEGIN
     veno := &empno;
     DELETE FROM emp WHERE empno = veno;
     IF SQL%FOUND THEN
         DBMS_OUTPUT.PUT_LINE('record deleted successfully');
    ELSE
         DBMS_OUTPUT.PUT_LINE('employee not exists');
   END IF;
     COMMIT;
  END;
   /

input :- 

Enter value for empno: 9090

output :- 

employee not exists

 Ex 2 :- 

 => write a prog for money transfer ? 

  ACCOUNTS
  ACCNO	ACTYPE	BAL
  100	S	10000
  101	S	20000

  DECLARE
      vsacno   accounts.accno%TYPE;
      vtacno   accounts.accno%TYPE;
      vamt      NUMBER(6);
      vbal       accounts.bal%TYPE;
      cnt1      NUMBER;
     cnt2       NUMBER;
 BEGIN 
      vsacno := &sacno;
      vtacno  := &tacno;
      vamt     := &amount;
      SELECT bal INTO vbal FROM accounts WHERE accno = vsacno; 
      IF  vamt > vbal THEN
          DBMS_OUTPUT.PUT_LINE('insufficient balance');
     ELSE
          UPDATE accounts SET bal = bal - vamt WHERE accno = vsacno;
          cnt1 := SQL%ROWCOUNT;
          UPDATE accounts SET bal = bal + vamt WHERE accno = vtacno;
          cnt2 := SQL%ROWCOUNT;
         IF cnt1=1 AND cnt2=1 THEN
              COMMIT;
        ELSE
            ROLLBACK;
        END IF;
   END IF;
   END;
    /

input :- 

Enter value for sacno: 100
Enter value for tacno: 999
Enter value for amount: 1000
 
NOTE :- 

 => every txn must gurantee a property called  " atomocity "  i.e. all or none ,
      if txn contains multiple operations if all are successful then it must be
      committed ,if one of the operation fails then entire txn must be cancelled

 => implicit cursor is useful to find whether individual operations are successful or not

   difference between explicit & implicit cursor  ? 

       explicit				  implicit

1   declared by user				declared by oracle

2  used to process select                                           used to process dml
    stmt output

3  name declared by user                                        name is always SQL


================================================================

16-NOV-23

COLLECTIONS :- 
------------------------ 

=> a collection allows group of elements of same datatype and elements are
     accessed by using index.

=> to use collection 

    1  declare collection type
    2  declare variable of collection type

 Declaring collection type :- 
 ------------------------------------

    TYPE  <name> IS TABLE OF <datatype>  INDEX BY <datatype>; 

  ex 1 :- 

    TYPE num_array IS TABLE OF NUMBER(3) INDEX BY BINARY_INTEGER; 

     x     num_array;

     x(1) := 10;
     x(2) := 20;
     x(3) := 30 ;

     x(10) := 100;

ex 2 :- 
 
  TYPE char_array IS TABLE OF VARCHAR2(10) INDEX BY BINARY_INTEGER ;

   s    char_array; 
 
      s(1) := 'abc';
      s(2) := 'xyz' ;
      
      s(10) := 'klm' ; 

ex 3 :- 

  TYPE  city_array IS TABLE OF NUMBER(2) INDEX BY VARCHAR2(3) ; 

  city   city_array;

 city('mum')  := 3;
 city('hyd')   := 1;
 city('che')   := 2 ;

DECLARE
   TYPE num_array IS TABLE OF NUMBER(3) INDEX BY BINARY_INTEGER;
   x   num_array;
BEGIN
   FOR i  IN 1..10
  LOOP
      x(i) := i*10;
  END LOOP;
  FOR i IN 1..10
 LOOP
    DBMS_OUTPUT.PUT_LINE(x(i));
 END LOOP; 
END;
/

x(1) = 10;
x(2) = 20;
x(3) = 30 

x(10) = 100

=> write a prog to print all dept names using collection ?

    DECLARE
        TYPE dname_array IS TABLE OF VARCHAR2(10) INDEX BY BINARY_INTEGER;
        d   dname_array;
    BEGIN
        FOR i in 1..4
    LOOP
        SELECT dname INTO d(i) FROM dept WHERE deptno = i*10;
   END LOOP;
       FOR i  IN 1..4
   LOOP
       DBMS_OUTPUT.PUT_LINE(d(i));
   END LOOP;
   END;
    /     


d(1) = ACCOUNTING
d(2) = RESEARCH
d(3) = SALES
d(4)= OPERATIONS

NOTE :- 

 1   logic to fetch values from dept table (where deptno = i*10) will work for dept
      table but not for other tables. 

  2  select stmt inside a loop , so no of requests going to oracle increases and
      it degrades performance.

 BULK COLLECT :- 
 ---------------------------
 
 => using "BULK COLLECT" we can fetch all the required data from table
      and assign to collection and BULK COLLECT reduces no of trips to 
      server and improves performance.

   DECLARE
        TYPE dname_array IS TABLE OF VARCHAR2(10) INDEX BY BINARY_INTEGER;
        d   dname_array;
    BEGIN
       SELECT dname BULK COLLECT INTO d FROM dept;
       FOR i  IN 1..4
   LOOP
       DBMS_OUTPUT.PUT_LINE(d(i));
   END LOOP;
   END;
    /     

  COLLECTION METHODS :- 
 --------------------------------------

  1  first     :-  returns index value of the first element 
  2  last     :-  returns index value of the last element
  3  next    :-  returns index value of the next element
  4  prior   :-  returns index value of the previous element
  5  count :-   returns total no of elements in collection
  6  exists :- to check whether element exists in the collection or not 
  7  delete :-  to delete element from collection

  collectionname.method

ex :- 

    DECLARE
        TYPE ename_array IS TABLE OF VARCHAR2(10) INDEX BY BINARY_INTEGER;
         e   ename_array;
    BEGIN
       SELECT ename BULK COLLECT INTO e FROM emp;
       FOR i  IN e.first..e.last
   LOOP
       DBMS_OUTPUT.PUT_LINE(e(i));
   END LOOP;
   END;
    /     

17-nov-23 

 => difference between cursor and collection ? 

	   CURSOR			COLLECTION

 1  fetching is row-by-row			we can fetch all rows at a time 
					and assigned to collection

 2  gives poor performance			gives good performance

 3  program consumes less memory		program consumes more memory

 4  suppors only forward navigation		supports both forward and backward navigation

 5  doesn't support random accessing		supports random accessing

 
 NOTE :- 

  => collection gives good performance but consumes more memory and cursor
       program consumes less memory but gives poor performance ,  so to balance
       memory and performance use combination of cursor and collection.

     DECLARE
         CURSOR C1 IS SELECT ENAME FROM EMP ;
         TYPE  ename_array IS TABLE OF VARCHAR2(10) INDEX BY BINARY_INTEGER;
         e  ename_array;
     BEGIN
          OPEN C1; 
     LOOP
         FETCH C1 BULK COLLECT INTO e LIMIT 4;
         FOR i IN e.first..e.last
       LOOP
           DBMS_OUTPUT.PUT_LINE(e(i));
       END LOOP;
       EXIT WHEN C1%NOTFOUND;
    END LOOP;
       CLOSE C1;
   END;
  /

ROWTYPE  array  OR BULK COLLECTING RECORDS :- 
---------------------------------------------------------------------------------

 DECLARE
   TYPE  emp_array IS TABLE OF EMP%ROWTYPE  INDEX BY BINARY_INTEGER;
   e  emp_array;
 BEGIN
    SELECT  *  BULK COLLECT INTO e FROM emp ; 
    FOR i in e.first..e.last
   LOOP
     DBMS_OUTPUT.PUT_LINE(e(i).ename||'    '||e(i).sal);
  END LOOP;
END;
 /

e(1)  =>  7369   SMITH   CLERK    17-DEC-80    800   NULL   20 
e(2)  => 



e(14)  => 


USER DEFINE RECORDS :- 
---------------------------------------

 => record structure defined by user called user define record.

 => when predefine record is not meeting  our requirements then we can create our own
      record structure called user define record.

 ex :-  
 
   TYPE emp_rec IS RECORD
   (
       eno        NUMBER(4),
       ename   VARCHAR2(10),
       sal         NUMBER(7,2)
   );

  e      emp_rec; 

 SELECT empno,ename,sal INTO e FROM emp WHERE empno = 7844; 

  e
  eno     ename   	sal
  7844   TURNER     1500


 DECLARE
   TYPE emp_rec IS RECORD
   (
       eno        NUMBER(4),
       ename   VARCHAR2(10),
       sal         NUMBER(7,2)
   );
   TYPE emp_array IS TABLE OF emp_rec INDEX BY BINARY_INTEGER;
   e    emp_array;
  BEGIN
      SELECT empno,ename,sal BULK COLLECT INTO e FROM emp ;
      FOR i IN e.first..e.last
      LOOP
            DBMS_OUTPUT.PUT_LINE(e(i).eno||'   '||e(i).ename||'   '||e(i).sal);
     END LOOP; 
  END;
    /
   
 
e(1) =>  7369  SMITH   800
e(2) => 7499   ALLEN  1600

 => write a prog to print all employee names and dept names ?

18-nov-23 

 => write a prog to increment all the employee salaries by 1000 ?

     DECLARE
        TYPE empno_array IS TABLE OF NUMBER(4) INDEX BY BINARY_INTEGER;
        e    empno_array;
     BEGIN
       SELECT empno BULK COLLECT INTO e FROM emp ;
       FOR i in e.first..e.last
       LOOP
            UPDATE emp SET sal = sal + 1000 WHERE empno = e(i);
      END LOOP;
      COMMIT;
   END;
       /

NOTE :- 

 => in the above example everty time for loop executes an element is passed
      from pl/sql engine to sql engine and sql engine executes update command
      and returns control back to pl/sql engine and this is called context switch ,
      and this degrades performance. To improve performace use BULK BIND.

BULK BIND :- 
--------------------

 => BULK BIND reduces context switch between pl/sql engine and sql engine
       and improves performance.

 => use BULK BIND for bulk insert,bulk update,bulk delete operations.

 => to use BULK BIND use FOR ALL loop instead of for loop.

           FORALL <var> IN <low>..<upp>
                 statement;

 => FORALL loop allows only one stmt and it must be dml stmt.
 
   DECLARE
        TYPE empno_array IS TABLE OF NUMBER(4) INDEX BY BINARY_INTEGER;
        e    empno_array;
        t1   timestamp;
        t2   timestamp;
     BEGIN
       SELECT empno BULK COLLECT INTO e FROM emp ;
       t1 :=  current_timestamp ; 
       FORALL i in e.first..e.last
            UPDATE emp SET sal = sal + 1000 WHERE empno = e(i);
       t2  := current_timestamp;
      COMMIT;
      DBMS_OUTPUT.PUT_LINE(t2-t1);
      END;
        / 

================================================================

ERROR HANDLING / EXCEPTION HANDLING :- 
----------------------------------------------------------------- 

 1 syntax errors
 2 logical errors
 3 runtime errors 

 => errors that are raised during progam execution are called runtime errors.

     ex :-    x   number(3);
 
                x := &x;  => 1000  => runtime error

 => if any statement causes runtime error then program execution is terminated
      and oracle displays error message. 

=> To replace system generated message with our own simple and user friendly
      message then we need to handle that runtime error.

 => To handle runtime error include a block called EXCEPTION block.

      DECLARE
          <declaration-part>;
      BEGIN
          <execution-part>;    => stmts causes exception
      EXCEPTION
          <error handling-part>;  => stmts handles exception
       END;
           /

 => if any statement causes exception then control is transferred to exception
      block and executes the statements in exception block.

 => exceptions are 2 types 
 
1  system defined
2  user defined

20-nov-23

system defined :- 
-----------------------

1   ZERO_DIVIDE               =>  raised when we try to divide number with 0
2   VALUE_ERROR            =>  raised when variable type or size mismatches
3   INVALID_NUMBER        => raised when invalid operation is performed.
4   NO_DATA_FOUND        => raised when data not found in table
5   TOO_MANY_ROWS      => raised when select stmt fetches more than one row
6   DUP_VAL_ON_INDEX  => raised when we try to insert duplicate values into primary key /
                                                 unique column 
  
 example 1 :- 

 DECLARE
   a  NUMBER(3);
   b  NUMBER(3);
   c  NUMBER(3);
BEGIN
   a := &a;
   b := &b;
   c := a/b;
   DBMS_OUTPUT.PUT_LINE(c);
EXCEPTION
  WHEN VALUE_ERROR THEN
       DBMS_OUTPUT.PUT_LINE('value exceeding size');
  WHEN ZERO_DIVIDE THEN
       DBMS_OUTPUT.PUT_LINE('divisor cannot be zero');
 END;
  /

Enter value for a: 10
Enter value for b: 0

 output :-   divisor cannot be zero

=> write a prog to input empno and print name & salary ? 

     DECLARE
        veno    emp.empno%TYPE;
        vename  emp.ename%TYPE;
        vsal    emp.sal%TYPE;
    BEGIN
        veno := &empno;
        SELECT ename,sal INTO vename,vsal FROM emp WHERE empno = veno;
        DBMS_OUTPUT.PUT_LINE(vename||'  '||vsal);
   EXCEPTION
       WHEN NO_DATA_FOUND THEN
             DBMS_OUTPUT.PUT_LINE('employee does not exists');
       WHEN VALUE_ERROR THEN
             DBMS_OUTPUT.PUT_LINE('value exceeding size');
      WHEN OTHERS THEN
             DBMS_OUTPUT.PUT_LINE('unknown error');
    END;
      /

  SQLCODE,SQLERRM :- 
  ----------------------------------

   SQLCODE => returns error code
   SQLERRM => returns error message

 CREATE TABLE EMP66
 (
  ENO   NUMBER(4) PRIMARY KEY,
  ENAME VARCHAR2(10) NOT NULL,
  SAL     NUMBER(7,2) CHECK(SAL>=3000) 
 );

 Write a prog to insert data into emp66 table ?

  DECLARE
      veno     emp66.eno%TYPE;
      vename  emp66.ename%TYPE;
      vsal       emp66.sal%TYPE;
 BEGIN
      veno := &empno;
      vename := '&ename' ;
      vsal  := &sal;
      INSERT INTO emp66 VALUES(veno,vename,vsal);
      COMMIT;
 EXCEPTION
      WHEN DUP_VAL_ON_INDEX THEN
             DBMS_OUTPUT.PUT_LINE('eno should not be duplicate');
     WHEN OTHERS THEN
             IF  SQLCODE =  -2290  THEN
                   DBMS_OUTPUT.PUT_LINE('sal>=3000');
              END IF;
 END;
  /

21-nov-23

PRAGMA EXCEPTION_INIT :- 
-------------------------------------------

 => using this we can give name to the errors that are not having predefine names

 ex :-  PRAGMA EXCEPTION_INIT(abc,-2290); 

 => exception "abc" must be declared in declaration part  as 
 
                   abc   exception; 

 => in program if any statement causes -2290 then oracle raises exception "abc" .
 
  DECLARE
      veno     emp66.eno%TYPE;
      vename  emp66.ename%TYPE;
      vsal       emp66.sal%TYPE;
      abc       exception;
      PRAGMA EXCEPTION_INIT(abc,-2290);
 BEGIN
      veno := &empno;
      vename := '&ename' ;
      vsal  := &sal;
      INSERT INTO emp66 VALUES(veno,vename,vsal);
      COMMIT;
 EXCEPTION
      WHEN DUP_VAL_ON_INDEX THEN
             DBMS_OUTPUT.PUT_LINE('eno should not be duplicate');
      WHEN abc THEN
             DBMS_OUTPUT.PUT_LINE('sal>=3000');
 END;
   /

USER DEFINED EXCEPTIONS :- 
----------------------------------------------

 => exceptions raised by user are called user defined exceptions 

 => user can raise exceptions by using

     1 RAISE statement
     2 RAISE_APPLICATION_ERROR procedure

using raise statement :- 
-------------------------------

          RAISE  <exception-name> ;

    ex :-   RAISE  abc; 

  => exception "abc" must be declared in declaration part as 

               abc   exception;

 DECLARE
   a  NUMBER(3);
   b  NUMBER(3);
   c  NUMBER(3);
   one_divide EXCEPTION;
BEGIN
   a := &a;
   b := &b;
   IF b=1 THEN
     RAISE one_divide;
   END IF;
   c := a/b;
   DBMS_OUTPUT.PUT_LINE(c);
EXCEPTION
  WHEN VALUE_ERROR THEN
       DBMS_OUTPUT.PUT_LINE('value exceeding size');
  WHEN ZERO_DIVIDE THEN
       DBMS_OUTPUT.PUT_LINE('divisor cannot be zero');
  WHEN ONE_DIVIDE THEN
       DBMS_OUTPUT.PUT_LINE('divisor cannot be one');
 END;
  /

Enter value for a: 10
Enter value for b: 1

output :- divisor cannot be one
  
 using raise_application_error :- 
 -----------------------------------------

   RAISE_APPLICATION_ERROR(error code,error msg);

      error code   =>  -20001 to -20999
      error msg    =>  any text 

  difference between raise & raise_application_error  ? 

  =>    use raise statement to raise exception and to handle exception 
          and use raise_application_error to raise exception and do not want
          to handle.

 ex :- 

   => write a prog to increment employee sal by specific amount but sunday
        updates are not allowed ?
 
       DECLARE
           veno   emp.empno%TYPE;
           vamt   number(4);
       BEGIN
           veno := &empno;
           vamt := &amount;
           IF TO_CHAR(SYSDATE,'dy')='sun' THEN
               RAISE_APPLICATION_ERROR(-20001,'sunday not allowed');
           END IF;
           UPDATE emp SET sal = sal + vamt WHERE empno = veno;
           COMMIT;
      END;
        /
  
 
ERROR at line 1:
ORA-20001: sunday not allowed
ORA-06512: at line 8

 =>  write a prog for money withdrawl ? 

  ACCOUNTS
  ACCNO   ACTYPE   BAL 
  100           S             10000

  DECLARE
       vacno    accounts.accno%type;
       vamt      NUMBER(5);
       vbal       accounts.bal%type;
  BEGIN
       vacno := &acno;
       vamt  := &amount;
       SELECT bal INTO vbal FROM accounts WHERE accno = vacno ; 
       IF vamt > vbal THEN
          RAISE_APPLICATION_ERROR(-20001,'insufficient balance');
       END IF;
       UPDATE accounts SET bal = bal - vamt WHERE accno = vacno;
       COMMIT;
  EXCEPTION
      WHEN NO_DATA_FOUND THEN
              RAISE_APPLICATION_ERROR(-20002,'account does not exists');
      WHEN OTHERS THEN
             RAISE_APPLICATION_ERROR(sqlcode,sqlerrm);
   END;
     / 

22-nov-23

Named PL/SQL blocks :- 
----------------------------------

procedures
functions
packages
triggers


SUB-PROGRAMS :- 
-----------------------------

 procedures
 functions 
 packages

Advantages :- 
--------------------

1  modular programming :- 
     ---------------------------------

   => with the help of procedures & functions a big pl/sql program can be divided into 
        small easily managable modules.
 
2  reusability :- 
 --------------------

 =>  procedures & functions are stored in db and applications which are connected to db
       can reuse procedures & functions .

3  invoked from front-end :- 
 -------------------------------------

 => procedures & functions can be called from front-end applications like java / .net

 4  improves performance :- 
    -----------------------------------

 =>  procedures & functions improves performance because they are precompiled
       i.e. compiled and ready for execution . when we create a procedure the
       program is compiled and stored in db and whenever we call procedure
       only execution is repeated but not compilation , so this improves performance.


 PROCEDURES :- 
 -------------------------

 => a procedure is a named PL/SQL block that accepts some input performs some action on db
      and may or may not returns a value.

 => procedures are created to perform one or more dml operations on db. 

 => procedures are 2 types 

   1  standalone or stored procedures
   2  packaged procedures 

standalone or stored procedures :- 
------------------------------------------------

=> these procedures are called standalone because they are stored as seperate object in db.
=> these procedures are called stored procedure because they are stored in db.

 CREATE OR REPLACE PROCEDURE <NAME>
 (
   parameters if any
 )
 IS
     <declaration-part>;
 BEGIN
     statements;
 END;
   /

parameters :- 
-------------------

 => we can declare parameters and we can pass values to parameters 

 => parameters are 3 types 

  1   IN
  2   OUT
  3   IN OUT  

 IN :- 
 --------

   => IN parameter always receives value 
   => default
   => read only 

OUT :- 
----------

 => OUT parameter always send value
 => write only

IN OUT :- 
-------------

 => receives and sends value
 => read & write 

                  parametername    type     datatype


   	main				proc
  
	A  ---------------------------------------------------> X (IN)

	B <---------------------------------------------------	Y (OUT)

	C ----------------------------------------------------> Z (IN OUT)
                    <------------------------------------------------------

  
  Example 1 :-  procedure without parameter

   => create procedure to increment all the employee salaries by 1000 ? 
 
       CREATE OR REPLACE PROCEDURE raise_salary
       IS
       BEGIN
            UPDATE emp SET sal = sal + 1000 ;
            COMMIT;
       END;
          /

 procedure created ( compiled + stored in db)

 Execution :- 
 ----------------

 1   sqlplus
 2   another pl/sql prog
 3   front-end

 executing from sqlplus :- 
 ----------------------------------

 SQL>EXECUTE  procname ;

 ex :-

 SQL>EXECUTE raise_salary ; 

24-nov-23

 Example 2 :-  procedure with parameters 

 => create a procedure to increment specific employee sal by specific amount ?

       CREATE OR REPLACE PROCEDURE raise_salary
       (
             peno IN NUMBER,
             pamt IN NUMBER
       )
       IS
       BEGIN
            UPDATE emp SET sal = sal + pamt WHERE empno = peno ; 
            COMMIT;
       END;
          /

 Execution :- 

  
SQL>EXECUTE raise_salary (7369,1000);                   positional association 

SQL>EXECUTE raise_salary(peno=>7369,pamt=>1000);    named association 

 SQL>EXECUTE raise_salary(pamt=>1000,peno=>7369);
 

executing from another pl/sql program :- 
--------------------------------------------------------
 
DECLARE
  veno   emp.empno%TYPE;
  vamt   NUMBER(5);
BEGIN
   veno := &empno;
   vamt := &amount;
   raise_salary(veno,vamt);                   /*  raise_salary(peno=>veno,pamt=>vamt) */ 
 END;
 /

Example 3 :-  procedure with OUT parameter

 => create procedure to increment specific employee sal by specific amount and 
      after increment send the updated sal to calling program ?

      CREATE OR REPLACE PROCEDURE raise_salary
      (
          peno  IN  NUMBER,
          pamt  IN  NUMBER,
          psal   OUT  NUMBER
      )
     IS
     BEGIN
            UPDATE emp SET sal = sal + pamt WHERE empno = peno;
            COMMIT;
            SELECT sal  INTO psal FROM emp WHERE empno = peno;
    END;
        /

Execution :- 

 DECLARE
  veno   emp.empno%TYPE;
  vamt   NUMBER(5);
  vsal    emp.sal%TYPE;
BEGIN
   veno := &empno; 
   vamt := &amount;   
   raise_salary(veno,vamt,vsal);
   DBMS_OUTPUT.PUT_LINE(vsal);
END;
 /
      
Declaring parameters with default value :- 
----------------------------------------------------------

=>  a parameter can be declared with default value as follows

              pamt   IN   NUMBER  DEFAULT 500 

 => while executing procedure if we don't pass value to parameter then oracle assigns default
      value.

   CREATE OR REPLACE PROCEDURE raise_salary
      (
          peno  IN  NUMBER,
          pamt  IN  NUMBER  DEFAULT 500,
          psal   OUT  NUMBER
      )
     IS
     BEGIN
            UPDATE emp SET sal = sal + pamt WHERE empno = peno;
            COMMIT;
            SELECT sal  INTO psal FROM emp WHERE empno = peno;
    END;
        /

Executing :- 

  DECLARE
  veno   emp.empno%TYPE;
  vsal    emp.sal%TYPE;
BEGIN
   veno := &empno; 
   raise_salary(peno=>veno,psal=>vsal);
   DBMS_OUTPUT.PUT_LINE(vsal);
END;
 /

25-nov-23 

 => create a procedure for money withdrawl ? 

    ACCOUNTS
    ACCNO	ACTYPE		BAL
   100		S		10000
   101		C		20000

    TRANSACTIONS
    TRID	TTYPE	TDATE	TAMT	ACCNO

    CREATE TABLE ACCOUNTS
    (
     ACCNO   NUMBER(4) PRIMARY KEY,
     ACTYPE  CHAR(1),
     BAL          NUMBER(8)
   );

   INSERT INTO ACCOUNTS VALUES(100,'S',10000);
   INSERT INTO ACCOUNTS VALUES(101,'C',20000);

   CREATE TABLE TRANSACTIONS
    (
        TRID      NUMBER ,
        TTYPE  CHAR(1),
        TDATE  TIMESTAMP,
        TAMT    NUMBER(5),
        ACCNO  NUMBER(4)  REFERENCES ACCOUNTS(ACCNO)
   );

 CREATE SEQUENCE S10
 START WITH 1
 INCREMENT BY 1
 MAXVALUE 9999 ; 

 CREATE OR REPLACE PROCEDURE DEBIT
 (
     pacno IN NUMBER, 
     pamt   IN  NUMBER,
     pbal    OUT  NUMBER
 )
 IS
  vbal  NUMBER;
 BEGIN
    SELECT bal INTO vbal FROM accounts WHERE accno = pacno ; 
    IF pamt > vbal THEN
       RAISE_APPLICATION_ERROR(-20002,'insufficient balance');
   END IF;
   UPDATE accounts SET bal = bal - pamt WHERE accno = pacno;
   INSERT INTO TRANSACTIONS VALUES(S10.NEXTVAL,'W',sysdate,pamt,pacno);
   COMMIT;
   SELECT bal INTO pbal FROM accounts WHERE accno = pacno;
EXCEPTION
     WHEN NO_DATA_FOUND THEN
              RAISE_APPLICATION_ERROR(-20001,'account does not exists');
END;
 /

Execution :- 

SQL>VARIABLE  K   NUMBER ;

 variable declared at sql prompt are called bind variables and bind variables
 are accessed by using : operator.

SQL>EXECUTE DEBIT(100,1000,:K);

 SQL>PRINT :K

=> create procedure for money deposit ?
=> create procedure for money transfer ?

procedures returning records :-
------------------------------------------

=> to return records from procedure  take out parameter of type

   1  CURSOR
   2  COLLECTION

using cursor :-
--------------------

=> create a procedure that accepts deptno and returns list of employees 
     working for that dept ? 

     CREATE OR REPLACE PROCEDURE getEmpList
     (
        pdno IN  NUMBER,
        pcur  OUT SYS_REFCURSOR 
      )
      IS
      BEGIN
          OPEN pcur FOR SELECT * FROM emp WHERE deptno = pdno;
      END;
        /

EXECUTION :- 

 SQL>variable  r  refcursor ; 
 SQL>EXECUTE  getEmpList(20,:r);
 SQL>PRINT :r

27-nov-23 

 executing from another pl/sql prog :-
 ---------------------------------------------------

 DECLARE
     vdno  NUMBER(2);
     vcur   SYS_REFCURSOR;
     e        emp%rowtype;
 BEGIN
     vdno := &deptno;   
     getEmpList(vdno,vcur);
  LOOP
      fetch vcur into e;
      exit when vcur%notfound;
      dbms_output.put_line(e.empno||'  '||e.ename||'  ' ||e.sal);
 END LOOP;
      close vcur;
 END;
 /

using collection :- 
------------------------

=> create a procedure that accepts deptno and returns list of employees 
     working for that dept ? 

     CREATE OR REPLACE PACKAGE P1
     AS
         TYPE emp_array IS TABLE OF emp%rowtype INDEX BY BINARY_INTEGER;
    END;
     /

     CREATE OR REPLACE PROCEDURE getEmpList
     (
        pdno IN  NUMBER,
        pemp  OUT  P1.emp_array
      )
      IS
      BEGIN
           SELECT * BULK COLLECT INTO pemp FROM emp WHERE deptno = pdno;
      END;
       /
       
Execution :- 

  DECLARE
   vdno  NUMBER(2);
   e            P1.emp_array;
  BEGIN
     vdno := &deptno;   
     getEmpList(vdno,e);
     FOR i in e.first..e.last
  LOOP
         DBMS_OUTPUT.PUT_LINE(e(i).empno||' '||e(i).ename||'  '||e(i).sal);
 END LOOP;
 END;
  /

 IN OUT parameter :- 
 -----------------------------

 => create a procedure to format phone ? 

      input  :-  19208991250

     output :-   +1 (920) 899-1250

 CREATE OR REPLACE PROCEDURE format_phone
 (
     phone  IN OUT  VARCHAR2
 )
IS
BEGIN 
    phone :=  '+1'||'  ('||SUBSTR(phone,2,3)||')'||'  '||SUBSTR(phone,5,3)||'-'||SUBSTR(phone,-4,4);
END;
 /

EXECUTION :- 

DECLARE
   p  VARCHAR2(20);
BEGIN
  p := 19208991250 ;
  format_phone(p);
  DBMS_OUTPUT.PUT_LINE(p);
END;
 /

USER DEFINE FUNCTIONS :- 
------------------------------------------

=> functions created by user are called user define functions.

=> when predefine functions not meeting our requirements then we create our own functions
     called user define functions.
 
=> a function is also a named PL/SQL block  that accepts some input performs some 
     calculation and must return a value.

  CREATE OR REPLACE FUNCTION <NAME>
  (
    parameters if any
  )  RETURN <type>
  IS
        declaration-part;
  BEGIN
       statements;
       RETURN <expr>;
 END;
   /

Example 1 :- 

 CREATE OR REPLACE FUNCTION CALC
 (
   a   NUMBER,
   b   NUMBER,
   op CHAR
 ) RETURN NUMBER
IS
BEGIN
   IF  op='+' THEN
      RETURN(a+b);
  ELSIF op='-' THEN
     RETURN(a-b);
 ELSIF op='*' THEN
    RETURN(a*b);
 ELSIF op='/' THEN
     RETURN(a/b);
 END IF;
END;
 /

 function created

EXECUTION :-

1  SQL commands
2  another pl/sql prog
3  front-end

executing from sql commands :- 
--------------------------------------------

SQL>SELECT CALC(10,20,'*') FROM DUAL ;  => 200
 

28-nov-23 

 => create a function that accepts deptno and returns names of the employees working for that
      dept ?

           INPUT  DEPTNO = 20 

          OUTPUT  SMITH,JONES,SCOTT,ADAMS,FORD

          CREATE OR REPLACE
                               FUNCTION getNames(d  NUMBER)  RETURN VARCHAR2
          IS
           CURSOR C1 IS SELECT ENAME FROM EMP WHERE DEPTNO = d ; 
           S   VARCHAR2(1000);
           BEGIN
               FOR  r IN C1
           LOOP
                S :=  S||r.ename||',' ;
           END LOOP;
           RETURN RTRIM(S,',');
           END;
               /

EXECUTION :-
 ---------------------
                
1  SELECT GETNAMES(20) FROM DUAL ;   => SMITH,JONES,SCOTT,ADAMS,FORD
 
2  SELECT DEPTNO,GETNAMES(DEPTNO) AS NAMES
    FROM EMP
    GROUP BY DEPTNO ; 

        30 	ALLEN,WARD,MARTIN,BLAKE,TURNER,JAMES
        10 	CLARK,KING,MILLER
        20	SMITH,JONES,SCOTT,ADAMS,FORD

 
LISTAGG :- 
---------------

  => it is a predefine function used to concatenate column values

       LISTAGG(COLNAME,SEPERATOR) WITHIN GROUP  (ORDER BY COL)

 EX :- 

1

  SELECT  LISTAGG(ENAME,',') WITHIN GROUP (ORDER BY HIREDATE ASC)
  FROM EMP ; 
      
2
    SELECT DEPTNO,LISTAGG(ENAME,',') WITHIN GROUP (ORDER BY SAL DESC) AS NAMES
    FROM EMP
    GROUP BY DEPTNO ;

  => create a function to calculate order amount of particular order ?

   ORDERS			PRODUCTS
   ordid   prodid     qty		prodid	pname	price
   1000    100          2			100	A	1000
   1000    101          1      		101	B	1500
   1000    102          2			102	C	500
   1001    100          2
    
           INPUT  :-   ordid  = 1000

           OUTPUT    amount  = 4500

  CREATE OR REPLACE 
            FUNCTION getOrdAmt(d  NUMBER) RETURN NUMBER
  IS
  CURSOR C1 IS SELECT O.PRODID,O.QTY,P.PRICE
                               FROM ORDERS O  INNER JOIN PRODUCTS P
                                   ON O.PRODID = P.PRODID
                              WHERE O.ORDID = d ;
vvalue  NUMBER;
vamt    NUMBER := 0;
BEGIN
   FOR r in C1
 LOOP
      vvalue :=  r.qty * r.price ; 
      vamt   :=   vamt + vvalue;
END LOOP;
 RETURN vamt;
END;
/

C1
prodid	qty	price
100	2	1000   
101	1	1500  
102	2	500 => r

execution :- 

 SELECT getOrdAmt(1000)  FROM DUAL ;   =>    4500


Questions :- 
------------------

   => is function can be created with out parameter ?

        ans  :- yes, but not recommended

 => function can contain multiple return statements ?

     ans :-  but always one return stmt is executed

 => procedure can contain return statements ? 

  ANS :- yes , but a return stmt in procedure cannot return value and returns control to the
  calling program.


   CREATE OR REPLACE PROCEDURE PRC1(e NUMBER)
   IS
  BEGIN
     UPDATE EMP SET SAL = SAL + 1000 WHERE EMPNO = e ;
     RETURN ;
  END;
    / 

=> difference between procedures & functions ?

	PROCEDURE		   	 FUNCTIONS

 1    may or may not returns a value            	 must return a value

 2   can return multiple values			always returns one value

 3  returns values using OUT parameter                    returns value using return stmt

 4  cannot be called from sql commands                   can be called from sql commands

 5  created to perform one or more                            creted for calculations or to fetch value
     dml operations                                                      from db

 6   create procedure to update balance                    create function to get balance

 
29-nov-23

USER_SOURCE :- 
---------------------------

 => stores list of procedures & functions created by user

 NAME	TYPE	LINE	TEXT
 PRC1      PROC     1                CREATE OR REPLACE 
                                2                IS
                                3                BEGIN
                                4                     UPDATE
                                5                      RETURN;
                                6                END;
          

    list of procedures & functions  ? 
 
    SELECT DISTINCT NAME,TYPE FROM USER_SOURCE ;

   display debit procedure code ?

   SELECT TEXT FROM USER_SOURCE WHERE NAME='DEBIT' ;     

  Droping :- 
  --------------

  DROP PROCEDURE RAISE_SALARY ; 

  DROP FUNCTION  ADDNUM ;

==========================================================================

 PACKAGES :- 
 ---------------------

  => a package is a collection of  procedures,functions,variables,cursors and types. 
  => related procedures & functions are grouped into one package.
  
 SERVER
       DATABASE
                USER
                         PROC
                         FUNC
                         PACKAGE
                                    PROC
                                    FUNC

 Advantages :- 
 --------------------

1  easy to manage :- 
 -----------------------------

=> related procedures & functions are encapsulated in one package so managing is easy.

2  supports overloading :- 
 -----------------------------------

 => standalone procedures & functions doesn't support overloading but in package we can
      define two or more proc / func with same name with different parameters.

3 supports hiding :- 
  ------------------------

  => in package we can make members (proc/func) as public and private , public members
       can be called from anywhere but private members can be called with in package.

4  improves performance :- 
    -----------------------------------  

  =>  when application calls proc/func in a package then oracle not only loads requested
        member but the whole package loaded into memory (instance)  and next
        request will not go to db  , so no of requests going to db are reduced and performance
        is improved.

=> package consists of two parts 

    1  package specification
    2  package body 

 package specification :- 
 -------------------------------- 

  => specification contains declarations of procedures,functions,variables,cursors,types etc

     CREATE OR REPLACE PACKAGE <NAME>
     AS
     procedure declaration ;
     function declaration;
     --------------------
     END;
      /

 package body :- 
 -----------------------

  => a package body contains definitions of procedures & functions declared in specification

   CREATE OR REPLACE PACKAGE BODY <NAME>
   AS
   procedure <name>(parameters)    
   is
   begin
         statements;
  end procname;
  function <name>(parameters) return type
  is
     variables;
  begin
       statements;
       return expr;
  end funname;

  END;
/

Example 1 :- 
 
=> create package to implement following operations ?

    1  to hire employee (proc)
    2  to fire employee  (proc)
    3  update salary      (proc)
    4  calculate experience  (func)
    5  top N employee list based on sal  (func) 

  EMP
  EMPNO  ENAME   JOB    MGR   HIREDATE  SAL   COMM   DEPTNO

  CREATE OR REPLACE PACKAGE HR
  AS
  PROCEDURE HIRE(E NUMBER,N VARCHAR2,J VARCHAR2,S NUMBER,D NUMBER);
  PROCEDURE FIRE(E NUMBER);
  PROCEDURE UPDATE_SAL(E  NUMBER,AMT NUMBER);
  FUNCTION EXPR(E NUMBER) RETURN NUMBER;
  FUNCTION GETTOPNEMPLIST(N NUMBER) RETURN SYS_REFCURSOR;
  END;
    /

 CREATE OR REPLACE PACKAGE BODY HR
 AS
  PROCEDURE HIRE(E NUMBER,N VARCHAR2,J VARCHAR2,S NUMBER,D NUMBER)
  IS
  BEGIN
      INSERT INTO EMP(EMPNO,ENAME,JOB,SAL,DEPTNO,HIREDATE)
                    VALUES(E,N,J,S,D,SYSDATE);
      COMMIT;
 END HIRE;
 PROCEDURE FIRE(E NUMBER)
 IS
 BEGIN
     DELETE FROM EMP WHERE EMPNO = E;
     COMMIT;
 END FIRE;
 PROCEDURE UPDATE_SAL(E  NUMBER,AMT NUMBER)
 IS
 BEGIN
         UPDATE EMP SET SAL = SAL + AMT WHERE EMPNO = E;
          COMMIT;
 END UPDATE_SAL;
 FUNCTION EXPR(E NUMBER) RETURN NUMBER
 IS
  vhire   DATE;
  vexpr  NUMBER;
 BEGIN
     SELECT HIREDATE INTO vhire FROM EMP WHERE EMPNO = E;
     vexpr :=  (SYSDATE - vhire)/365;
     RETURN vexpr;
 END EXPR;
 FUNCTION GETTOPNEMPLIST(N NUMBER) RETURN SYS_REFCURSOR
 IS
    vcur  SYS_REFCURSOR;
 BEGIN
     OPEN vcur FOR  SELECT *
                                 FROM (SELECT EMPNO,ENAME,SAL,
                                                DENSE_RANK() OVER (ORDER BY SAL DESC) AS RNK
                                            FROM EMP) E 
                                   WHERE RNK<=N ;
   RETURN vcur;
 END GETTOPNEMPLIST;
END;
 /

execution :- 
-----------------

 => whole package cannot be executed only members of the package can be executed 

                 PACKAGENAME.MEMBER(parameters); 

   SQL>EXECUTE  HR.HIRE(100,'ABC','CLERK',4000,20);

  SQL>EXECUTE HR.UPDATE_SAL(100,1000);

01-dec-23

 => create package to implement various bank transactions ?

 ACCOUNTS
 ACCNO	ACTYPE	BAL

 TRANSACTIONS
 TRID	TTYPE	TDATE	TAMT	ACCNO

 CREATE SEQUENCE S10
 START WITH 1
 INCREMENT BY 1
 MAXVALUE 99999 ; 

 1  account opening (proc)
 2  account closing  (proc)
 3  balance enquiry (func)
 4  money deposit   (proc)
 5 money withdrawl (proc)
 6 money transfer   (proc)
 7 statement between two given dates (func)
 8 latest N transactions  (func) 

 specification :- 
 --------------------

CREATE OR REPLACE PACKAGE BANK
AS
PROCEDURE OPEN_ACCT(a  NUMBER,t CHAR,b NUMBER);
PROCEDURE CLOSE_ACCT(a  NUMBER);
FUNCTION  GETBAL(a  NUMBER)  RETURN NUMBER;
PROCEDURE CREDIT(a  NUMBER,amt NUMBER);
PROCEDURE DEBIT(a NUMBER,amt NUMBER);
PROCEDURE TRANSFER(s NUMBER,t NUMBER,amt NUMBER);
FUNCTION  STMT(a NUMBER,s DATE,e DATE)  RETURN SYS_REFCURSOR;
FUNCTION  STMT(a  NUMBER,n NUMBER) RETURN SYS_REFCURSOR;
END;
 /
  
 package body :- 
 ------------------------

CREATE OR REPLACE PACKAGE BODY BANK
AS
PROCEDURE OPEN_ACCT(a  NUMBER,t CHAR,b NUMBER)
IS
BEGIN
     INSERT INTO  ACCOUNTS VALUES(a,t,b);
     COMMIT;
END OPEN_ACCT;
PROCEDURE CLOSE_ACCT(a  NUMBER)
IS
BEGIN
    DELETE FROM ACCOUNTS WHERE ACCNO = a;
    COMMIT;
END CLOSE_ACCT;
FUNCTION  GETBAL(a  NUMBER)  RETURN NUMBER
IS
vbal  NUMBER;
BEGIN 
   SELECT BAL INTO vbal FROM ACCOUNTS WHERE ACCNO = a;
   RETURN vbal;
END GETBAL;
PROCEDURE CREDIT(a  NUMBER,amt NUMBER)
IS
BEGIN
    UPDATE ACCOUNTS SET BAL = BAL + amt WHERE ACCNO = a;
    INSERT INTO TRANSACTIONS VALUES(s10.nextval,'D',sysdate,amt,a);
    COMMIT;
END CREDIT;
PROCEDURE DEBIT(a  NUMBER,amt NUMBER)
IS
vbal NUMBER;
BEGIN
    vbal :=  GETBAL(a);
    IF  amt > vbal THEN
         RAISE_APPLICATION_ERROR(-20001,'insufficient balance');
    END IF;
    UPDATE ACCOUNTS SET BAL = BAL - amt WHERE ACCNO = a;
    INSERT INTO TRANSACTIONS VALUES(s10.nextval,'W',sysdate,amt,a);
    COMMIT;
END DEBIT;
PROCEDURE TRANSFER(s NUMBER,t NUMBER,amt NUMBER)
IS
BEGIN
    DEBIT(s,amt);
    CREDIT(t,amt);
END TRANSFER;
FUNCTION  STMT(a NUMBER,s DATE,e DATE)  RETURN SYS_REFCURSOR
IS
 C1 SYS_REFCURSOR;
BEGIN
    OPEN C1 FOR  SELECT *
                              FROM TRANSACTIONS
                              WHERE ACCNO = a
                                            AND
                                            TDATE BETWEEN s AND e ; 

  RETURN C1;
END STMT;
FUNCTION  STMT(a  NUMBER,n NUMBER) RETURN SYS_REFCURSOR
IS
C1 SYS_REFCURSOR;
BEGIN
  OPEN C1 FOR SELECT *
                          FROM (SELECT *
                                      FROM TRANSACTIONS
                                      WHERE ACCNO = a
                                        ORDER BY TDATE DESC ) 
                            WHERE ROWNUM <= n ; 
  RETURN C1;
END STMT;
END;
/


 EXECUTION :- 

SQL>EXECUTE  BANK.OPEN_ACCT(111,'S',10000);
 
SQL>EXECUTE BANK.CREDIT(100,5000);

SQL>EXECUTE BANK.DEBIT(100,1000);

SQL>SELECT BANK.STMT(100,3) FROM DUAL ;

Droping :- 
---------------

SQL>DROP PACKAGE   HR ;   => drops both specification & body 

SQL>DROP PACKAGE BODY BANK ;  => drops only body but not speciation


USER_SOURCE :- 
-----------------------------

 list of packages created by user ? 
 
      SELECT DISTINCT NAME,TYPE
      FROM USER_SOURCE
     WHERE TYPE='PACKAGE' ;
 
  02-DEC-23

  TRIGGERS :- 
  -----------------

   =>  a trigger is also a named PL/SQL block like procedure but executed
         implicitly whenever user submits dml commands to oracle.

   => triggers are created 

       1 to control dmls 
       2 to enforce complex rules & validations 
       3 to audit day-to-day operations on tables
       4 to manage replicas (duplicate copy)
       5 to generate values for primary key columns 
 
syntax :- 
-----------

  CREATE OR REPLACE TRIGGER <NAME>
  BEFORE / AFTER INSERT OR UPDATE OR DELETE
  ON <TABNAME>
  [FOR EACH ROW]
  [
       DECLARE
            variables;
  ]
  BEGIN
       statements;
  END;
    /

BEFORE triggers :- 
---------------------------

=> if trigger is before then oracle executes the trigger before executing dml.
 
   1 trigger
   2 dml

AFTER trigger :-
-----------------------

  => if trigger is after then oracle executes the trigger after executing dml

   1 dml
   2 trigger

Trigger levels :- 
--------------------

 1  statement level  (default)
 2   row level

statement level :- 
------------------------

 => statement level triggers are executed once per the statement.

row level :- 
--------------

  => row level triggers are executed once per the row affected by dml.
  => row level triggers are created with FOR EACH ROW option.

  ex :- 

  => create trigger to not to allow dmls on emp table on sunday ?
 
     CREATE OR REPLACE TRIGGER T1
     BEFORE INSERT OR UPDATE OR DELETE
     ON EMP
     BEGIN
             IF TO_CHAR(SYSDATE,'DY')='SUN' THEN
                 RAISE_APPLICATION_ERROR(-20001,'sunday not allowed');
             END IF;
    END;
      /

  Testing :-   (sysdate = sunday)
  -----------
 
 sql>update emp set sal = 1000 where empno = 7844 ;  => error

 ex 2 :- 

  create trigger to not to allow to dmls on emp table as follows ?

         MON  - FRI      <10am and >4pm

         SAT                 <10am and >2pm
 
        SUN                   ---------------------

  CREATE OR REPLACE TRIGGER T2
  BEFORE INSERT OR UPDATE OR DELETE
  ON EMP
  BEGIN
        IF TO_CHAR(SYSDATE,'D')  BETWEEN 2 AND 6
            AND
            TO_CHAR(SYSDATE,'HH24') NOT BETWEEN 10 AND 15  THEN
                  RAISE_APPLICATION_ERROR(-20001,'only between 10am and 4pm');
       ELSIF TO_CHAR(SYSDATE,'DY')='SAT' 
                  AND
                 TO_CHAR(SYSDATE,'HH24') NOT BETWEEN 10 AND 13 THEN
                      RAISE_APPLICATION_ERROR(-20001,'only between 10am and 2pm');
       ELSIF TO_CHAR(SYSDATE,'DY')='SUN' THEN
                  RAISE_APPLICATION_ERROR(-20001,'sunday not allowed');
       END IF;
   END;
   /

 Testing :- 

  SQL>UPDATE EMP SET SAL = 2000 WHERE EMPNO = 7844 ; 

 => create trigger to not to allow to update empno ?

   CREATE OR REPLACE TRIGGER T3
   BEFORE UPDATE OF EMPNO 
   ON EMP
   BEGIN
           RAISE_APPLICATION_ERROR(-20001,'empno cannot be updated');
  END;
    /

Testing :- 

sql>update emp set empno = 9999 where empno = 7844 ;   => ERROR
 
 :NEW, :OLD variables :- 
 -------------------------------------

   => these two variables are called bind variables and rowtype variabes
   => with the help of these two variables in triggers we can access data affected by dmls
   => record user is trying to insert is copied to :NEW variable
   => record user is trying to delete is copied to :OLD variable
   => record user is trying to update is copied to both :OLD & :NEW variables 

      INSERT INTO EMP VALUES(100,'A','CLERK',4000,---)   =>  :NEW
                                                                                                       EMPNO ENAME JOB        SAL
                                                                                                       100        A            CLERK   4000

       DELETE FROM EMP WHERE EMPNO = 7369 ;    =>       :OLD
                                                                                                   EMPNO  ENAME  JOB         SAL
                                                                                                   7369       SMITH    CLERK    800

      UPDATE EMP SET SAL = 5000 WHERE EMPNO = 100 ;  =>   :OLD
                                                                                                           EMPNO  SAL
                                                                                                           100         4000

                                                                                                          :NEW
                                                                                                          EMPNO   SAL
                                                                                                          100           5000

 => these two variables are allowed only in row level triggers but not allowed in statement level
      triggers 


03-DEC-23 (sunday) :- 
-------------------------------

=>  create trigger to not to allow to decrement salary ? 

    CREATE OR REPLACE TRIGGER T4
    BEFORE UPDATE
    ON EMP
    FOR EACH ROW
    BEGIN
         IF :NEW.SAL < :OLD.SAL THEN
            RAISE_APPLICATION_ERROR(-20001,'sal cannot be decremented');
        END IF;
    END;
      /

 Testing :- 
 ----------------

 SQL> UPDATE EMP SET SAL = 2000 WHERE EMPNO = 7369; => ERROR

=> create trigger to insert details into emp_resign when employee resigns ?

 EMP_RESIGN
 EMPNO  ENAME    HIREDATE    DOR 

 CREATE TABLE EMP_RESIGN
 (
   EMPNO  NUMBER(4),
   ENAME   VARCHAR2(10),
   HIREDATE DATE,
   DOR DATE
  );

CREATE OR REPLACE TRIGGER T5
AFTER DELETE
ON EMP
FOR EACH ROW
BEGIN
   INSERT INTO EMP_RESIGN 
         VALUES(:OLD.EMPNO,:OLD.ENAME,:OLD.HIREDATE,SYSDATE);
END;
 /

Testing :- 

1  DELETE FROM EMP WHERE EMPNO = 7369 ;  

 2  SELECT * FROM EMP_RESIGN ; 

Auditing :- 
-------------

 => auditing means monitoring day-to-day activities on tables 
 => with the help of auditing we can capture dml operations on tables 

Ex :- 

  EMP_AUDIT
  UNAME  OPERATION   OPTIME   NEW_ENO   NEW_ENAME  NEW_SAL   OLD_ENO   OLD_ENAME     OLD_SAL

  CREATE TABLE EMP_AUDIT 
  (
   UNAME  VARCHAR2(20),
    OPERATION VARCHAR2(10),
    OPTIME        TIMESTAMP ,
    NEW_ENO    NUMBER(4),
    NEW_ENAME  VARCHAR2(10),
    NEW_SAL      NUMBER(7,2),
    OLD_ENO    NUMBER(4),
    OLD_ENAME  VARCHAR2(10),
   OLD_SAL      NUMBER(7,2)
   );

 CREATE OR REPLACE TRIGGER T6
 AFTER INSERT OR UPDATE OR DELETE
 ON EMP
 FOR EACH ROW
 DECLARE
      OP   VARCHAR2(10);
  BEGIN
       IF INSERTING THEN
           OP := 'INSERT' ;
      ELSIF  UPDATING THEN
           OP := 'UPDATE';
     ELSE
          OP := 'DELETE';
     END IF;
     INSERT INTO EMP_AUDIT
          VALUES(USER,OP , SYSDATE,:NEW.EMPNO,:NEW.ENAME,:NEW.SAL,
                              :OLD.EMPNO,:OLD.ENAME,:OLD.SAL);
 END;
  /

Testing :- 
-------------

 sql>insert into emp(empno,ename,sal) values(999,'KKK',4000);
 sql>update emp set sal=5000 where empno = 999;
 sql>delete from emp where empno =  999;

 sql>select * from emp_audit ; 

 how many triggers can be created on table ?

 ans :- 12

what is order of execution of triggers ?

 before stmt
 before row
 after row
 after stmt 

04-dec-23

compound trigger :- 
----------------------------

 => using compound trigger we can define multiple triggers in one triggers.
 => introduced in oracle 11g

 CREATE OR REPLACE TRIGGER T7
 FOR  UPDATE
 ON EMP
 COMPOUND TRIGGER
 
  BEFORE STATEMENT IS
  BEGIN
    dbms_output.put_line('before stmt');
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
       dbms_output.put_line('before row');
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
      dbms_output.put_line('after row');
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
        dbms_output.put_line('after stmt');
  END AFTER STATEMENT;
END;

 Testing :- 

 SQL>UPDATE EMP SET SAL=SAL+1000 WHERE EMPNO IN (7844,7902);

before stmt
before row
after row
before row
after row
after stmt

USER_TRIGGERS :- 
-----------------------------

  => stores triggers created by user

Droping :- 
-------------
 
SQL>DROP TRIGGER T1 ; 

 if we drop table what about triggers created on table ?

  ans :- triggers are also dropped

 SERVER
        DATABASE   
                    USER
                           TABLE
                                      ROWS & COLS
                                      CONSTRAINTS
                                      INDEXES
                                      TRIGGERS
                            VIEW
                            SYNONYM
                            SEQUENCE
                            MATERIALIZED VIEW
                            PROCEDURE
                            FUNCTION
                            PACKAGE

 =================================================================

 Dynamic SQL :- 
 ---------------------

 => SQL commands generated at runtime are called dynamic SQL commands

          ex :-   DROP TABLE emp ;    (static sql command)

                     tname   varchar2(10)
                     tname := '&tabname' ;
                     drop table tname ;     (dynamic sql command)

 => dynamic sql is useful when we don't know tablenames and column names
      until runtime.

 => Dynamic sql commands and DDL commands are executed by using 
      EXECUTE IMMEDIATE.

               EXECUTE IMMEDIATE   '  dynamic sql command / ddl command ' ;

  => dynamic sql / ddl  command that you want to execute should be passsed
       as a string to EXECUTE IMMEDIATE.

example 1 :- 

 BEGIN
     EXECUTE IMMEDIATE  ' DROP TABLE EMP55 '  ; 
 END;
  /

example 2 :- 

create a procedure to drop table ? 

CREATE OR REPLACE PROCEDURE DROP_TABLE
(
   tname  IN VARCHAR2
)
IS
BEGIN
    EXECUTE IMMEDIATE  ' DROP TABLE ' || tname ;
 END;
 /

 EXECUTE :- 

 SQL>EXECUTE DROP_TABLE('CUST');

 example 3 :- 

  => create a procedure to drop all tables created in schema ?

   CREATE OR REPLACE PROCEDURE DROP_ALL_TABLES
   IS
   CURSOR C1 IS SELECT TABLE_NAME FROM USER_TABLES
                              MINUS
                              SELECT MVIEW_NAME FROM USER_MVIEWS;
  BEGIN
        FOR r IN C1
    LOOP
         EXECUTE IMMEDIATE  ' DROP  TABLE ' ||r.TABLE_NAME ||'  CASCADE CONSTRAINTS ' ;
    END LOOP;
 END;
  /

EXECUTION :- 

 SQL>EXECUTE DROP_ALL_TABLES ; 

 => create a procedure to truncate all tables ? 

  => write a prog to print no of rows in each and every table ?

       EMP    	?
       DEPT 	 ?
       CUST  	?
       STUDENT 	 ?

  DECLARE
  CURSOR C1 IS SELECT TABLE_NAME FROM USER_TABLES   ;            
  str  VARCHAR2(500);
  cnt   NUMBER;
  BEGIN
        FOR r IN C1
    LOOP
         str  := 'SELECT COUNT(*)  FROM ' ||r.TABLE_NAME ; 
         EXECUTE IMMEDIATE str INTO cnt;
         DBMS_OUTPUT.PUT_LINE(r.TABLE_NAME||'   '||cnt);
    END LOOP;
 END;
   /

05-DEC-23

 UTL_FILE package :- 
 -------------------------------

 => predefined package used to work with files.
 => using this package we can create new files,write data and read data from files.
  
members of the package :-
-------------------------------------

 1  FILE_TYPE => it is a type used to declare file variable
 2  FOPEN       =>  it is a function used to open file
 3  PUT_LINE   =>  it is a procedure used to write data into file
 4  GET_LINE  =>   it is also a procedure used to get data from file
 5  FCLOSE     =>   it is a procedure used to close file
  
 Directory Object :- 
 -------------------------

 => It is an object in db that points to operating system directory
 => created by dba and granted  to users 

 SYSTEM :- 
 ---------------

SQL>CREATE DIRECTORY D77 AS 'D:\NARESH' ;

SQL> GRANT READ,WRITE ON DIRECTORY D77 TO BATCH730;

BATCH730 :- 
------------------

Example 1 :-  program to create new file and write data 

DECLARE
   f1   utl_file.file_type ; 
BEGIN 
   f1 := utl_file.fopen('D77','abc.txt','w');
   utl_file.put_line(f1,'hello');
   utl_file.put_line(f1,'welcome');
   utl_file.put_line(f1,'to utl_file package');
   utl_file.fclose(f1);
END;
 /

Example 2 :- program to read data from file 

 DECLARE
   f1   utl_file.file_type;
   s     varchar2(1000);
 BEGIN
   f1 :=  utl_file.fopen('D77','abc.txt','r');
  loop
     utl_file.get_line(f1,s);
     dbms_output.put_line(s);
 end loop; 
 exception
        when no_data_found then
                utl_file.fclose(f1);
END;
 /

Example 3 :- program to copy data from emp table to file

DECLARE
  f1   utl_file.file_type;
  cursor c1 is select empno,ename,sal from emp ;
  str   VARCHAR2(1000);
BEGIN
    f1 := utl_file.fopen('D77','emp.txt','w');
   FOR r  IN c1
LOOP
     str := r.empno||','||r.ename||','||r.sal;
     utl_file.put_line(f1,str);
END LOOP;
utl_file.fclose(f1);
END;
 /

program to copy data from table to csv file (comma seperated value) :- 
----------------------------------------------------------------------------------------------------

DECLARE
  f1   utl_file.file_type;
  cursor c1 is select empno,ename,sal from emp ;
  str   VARCHAR2(1000);
BEGIN
    f1 := utl_file.fopen('D77','emp.csv','w');
   FOR r  IN c1
LOOP
     str := r.empno||','||r.ename||','||r.sal;
     utl_file.put_line(f1,str);
END LOOP;
utl_file.fclose(f1);
END;
 /
 
06-dec-23

 program to copy data from text/csv file to oracle table :- 
 -------------------------------------------------------------------------

 source :-  d:\naresh\emp.csv

 target :- 

  create table emp66
  (
   eno  number(4),
   ename varchar2(10),
   sal    number(7)
  );

  DECLARE
     f1  utl_file.file_type;
     veno  NUMBER(4);
     vename VARCHAR2(10);
     vsal       NUMBER(7);
     s           VARCHAR2(100);
   BEGIN
      f1 := utl_file.fopen('D77','emp.csv','r');
 LOOP  
      utl_file.get_line(f1,s);
      veno :=  REGEXP_SUBSTR(s,'[^,]+',1,1);
      vename := REGEXP_SUBSTR(s,'[^,]+',1,2);
      vsal   := REGEXP_SUBSTR(s,'[^,]+',1,3);
      INSERT INTO emp66 VALUES(veno,vename,vsal);
  END LOOP;
  EXCEPTION
        WHEN NO_DATA_FOUND THEN
                     utl_file.fclose(f1);
                     commit;
   END;
     /

   s = 7369,smith,800

  REGEXP_SUBSTR(string,pattern,start,occurance);

===============================================================

 Working with Binary Data :- 
 ------------------------------------

 => Binary Types are used for storing multimedia objects like audio,video,images
 => oracle supports 2 binary types 

 1 BFILE (binary file large object)
 2 BLOB (binary large object)

 using BFILE :- 
 -------------------- 

 => bfile is called external lob because  lob stored outside db but db stores path
      called locator.

 => to store locator in db use function BFILENAME

                  BFILENAME(dir obj,filename) 

example :- 

 create table cust
 (
  cid   number(4),
  cname varchar2(10),
  cphoto  bfile
  );

 INSERT INTO cust VALUES(10,'A',BFILENAME('D77','flower.jpg'));

07-dec-23

using BLOB :- 
------------------

 => blob is called internal lob because lob stored inside db

example :- 

 CREATE TABLE cust
 (
  cid NUMBER(2),
  cname VARCHAR2(10),
  cphoto  BLOB
  );

 INSERT INTO cust VALUES(10,'A',EMPTY_BLOB());

create procedure to update customer photo ? (file to blob)

CREATE OR REPLACE PROCEDURE update_cust_photo
(
    pcid IN NUMBER,
    pfile  IN  VARCHAR2
)
IS
 s  BFILE;
 t  BLOB;
 x  NUMBER;
BEGIN
    s := BFILENAME('D77',pfile);
    SELECT cphoto INTO t FROM CUST WHERE CID = pcid  FOR UPDATE ; 
    DBMS_LOB.OPEN(s,DBMS_LOB.LOB_READONLY);
    x := DBMS_LOB.GETLENGTH(s);
    DBMS_LOB.LOADFROMFILE(t,s,x);
    UPDATE  CUST SET CPHOTO = t WHERE CID = pcid;
    COMMIT;
    DBMS_LOB.CLOSE(s);
 END;
   /

Execution :- 

 SQL>INSERT INTO CUST VALUES(11,'B',EMPTY_BLOB());

 SQL>SELECT LENGTH(CPHOTO) FROM CUST WHERE CID=11; => 0 

 SQL>EXECUTE UPDATE_CUST_PHOTO(11,'BUTTERFLY.jpg');

 SQL>SELECT LENGTH(CPHOTO) FROM CUST WHERE CID=11; => 34158
 
procedure to copy  blob content to file :- 
------------------------------------------------------

CREATE OR REPLACE PROCEDURE blob_to_file
(
   pcid  IN  NUMBER,
   pfile  IN  VARCHAR2
 )
IS
  l_file      UTL_FILE.FILE_TYPE;
  l_buffer    RAW(32767);
  l_amount    BINARY_INTEGER := 32767;
  l_pos       INTEGER := 1;
  l_blob      BLOB;
  l_blob_len  INTEGER;
BEGIN
  -- Get LOB locator
  SELECT cphoto
  INTO   l_blob
  FROM  cust
  WHERE cid = pcid;

  l_blob_len := DBMS_LOB.getlength(l_blob);
  
  -- Open the destination file.

  l_file := UTL_FILE.fopen('D77',pfile,'wb', 32767);

  -- Read chunks of the BLOB and write them to the file
  -- until complete.
  WHILE l_pos <= l_blob_len 
 LOOP
    DBMS_LOB.read(l_blob, l_amount, l_pos, l_buffer);
    UTL_FILE.put_raw(l_file, l_buffer, TRUE);
    l_pos := l_pos + l_amount;
  END LOOP;
  
  -- Close the file.
  UTL_FILE.fclose(l_file);
  
EXCEPTION
  WHEN OTHERS THEN
    -- Close the file if something goes wrong.
    IF UTL_FILE.is_open(l_file) THEN
      UTL_FILE.fclose(l_file);
    END IF;
    RAISE;
END;
/

Execution :- 
 
SQL> execute  blob_to_file(11,'abc.jpg');

summary :- 

 cursors
 collections
 error handling
 procedures
 functions
 packages
 triggers
 dynamic sql
 utl_file
 blob/bfile

=========================================================================

TABLE PARTITIONING :- (SQL)
---------------------------------

 => Dividing table into multiple parts called table partitioning.
 => table is called partitioned table and parts are called partitions.
 => used if table contains more than 2GB of data.

 Advantages :- 
 ------------------

 1 improves performance :- 
   ---------------------------------

  =>  searching for the record in partition is faster than searching for the record in table

 2 improves availability :- 
  --------------------------------

  => if particular partition is damaged then only the records assigned to that partition are 
       not available and remaining records are available to the application.

 3 simplifies administration :- 
    ----------------------------------

  => DBA can perform backup & restore operations at partition level instead taking
       backup of whole table.

 => partitioning is 3 types 

  1  Range partitioning
  2  List partitioning
  3  Hash partitioning

 Range partitioning :- 
 ---------------------------

  => in range partitioning which record assigned to which partition depends on partition key range

 CREATE TABLE EMP_RANGE
 (
   EMPNO   NUMBER(4) ,
   ENAME    VARCHAR2(10),
   SAL          NUMBER(7,2)
  )
  PARTITION BY RANGE(SAL)
  (
    PARTITION P1 VALUES LESS THAN (2001),
    PARTITION P2 VALUES LESS THAN (4001),
    PARTITION P3 VALUES LESS THAN(MAXVALUE)
   );

 INSERT INTO EMP_RANGE VALUES(1,'A',5000);
 INSERT INTO EMP_RANGE VALUES(2,'B',1000);
 INSERT INTO EMP_RANGE VALUES(3,'C',3000);


1    SELECT * FROM EMP_RANGE WHERE SAL = 3000 ; 

     for the above query oracle goes to partition p2 and search for the record sal = 3000 
     searching for the record in partition takes less time compare to searching for the
     record in table.
 
 2   SELECT * FROM EMP_RANGE ; 

      for the above query oracle parallely reads data from all partitions and combine the data
      by using union operator.
 
3   SELECT * FROM EMP_RANGE PARTITION (P2) ; 

      above query returns data from partition p2 

  Droping partiiton :- 
  ---------------------------
 
  SQL>ALTER TABLE EMP_RANGE
                                DROP PARTITION P3 ; 

   when partition is dropped then records stored in partition are also deleted 
 
  Adding partition :- 
  -----------------------
 
   SQL>ALTER TABLE EMP_RANGE
                 ADD PARTITION P3 VALUES LESS THAN (6001) ; 

    INSERT INTO EMP_RANGE VALUES(1,'A',8000); => ERROR

 LIST partitioning ;- 
 --------------------------

 => in list partitioning which record assigned to which partition depends on value of the
      partition key.

  CREATE TABLE EMP_LIST
  (
   EMPNO  NUMBER(4),
   ENAME  VARCHAR2(10),
   JOB        VARCHAR2(10)
  )
  PARTITION BY LIST(JOB)
  (
    PARTITION P1 VALUES ('ANALYST','CLERK'),
    PARTITION P2 VALUES ('SALESMAN','MANAGER'),
    PARTITION P3 VALUES(DEFAULT)
  );

   INSERT INTO EMP_LIST VALUES(100,'A','CLERK');
   INSERT INTO EMP_LIST VALUES(101,'B','MANAGER');
 
   SELECT * FROM EMP_LIST WHERE JOB='CLERK'  ;   

  oracle goes to partition p1 and search for the records job='CLERK' 

  HASH partitioning :- 
  --------------------------
 
  => in hash partitioning which record assigned to which partition depends on output of
       hash function applied on partition key 

     CREATE TABLE EMP_HASH
     (
        EMPNO  NUMBER(4),
        ENAME  VARCHAR2(10),
        DNO        NUMBER(2)
     )
     PARTITION BY HASH(DNO)
     PARTITIONS 4 ; 

09-dec-23

 EXISTS & NOT EXISTS operators :- 
 -------------------------------------------------

 => these two operators are used to check existence of the record in the table i.e. 
      whether record exists in the table or not

   SELECT columns
   FROM tabname
   WHERE  EXISTS (SELECT STATEMENT) ; 

   => EXISTS returns TRUE / FALSE 

        TRUE    => if subquery returns atleast one row (record exists)
        FALSE  =>   if subquery returns 0 rows (record not exists) 

 scenario :- 
 ---------------

 DEPT                                                            EMP
 DEPTNO  DNAME  			  EMPNO	ENAME	SAL	DEPTNO
 10            ACCTS			  1	A	3000	10
 20           RESEARCH 		  2	B	4000	20
 30           SALES			  3	C	5000	30
 40           OPERATIONS		  4	D	2000	10

=> display departments which are not empty ?

    SELECT *
    FROM DEPT  D
    WHERE EXISTS (SELECT * FROM EMP WHERE DEPTNO =  D.DEPTNO) ; 

  10      ACCTS                WHERE EXISTS (WHERE DEPTNO = 10)    TRUE
  20     RESEARCH         WHERE EXISTS (WHERE DEPTNO = 20)    TRUE
  30     SALES                  WHERE EXISTS (WHERE DEPTNO = 30)   TRUE
  40     OPERATIONS       WHERE EXISTS (WHERE DEPTNO = 40)   FALSE 

using IN :- 
----------------
  
    SELECT *
    FROM DEPT  D
    WHERE  DEPTNO IN (SELECT DEPTNO FROM EMP) ;
			10
			20
			30
 				
 NOTE :- oracle recommends EXISTS operator than IN operator because EXISTS gives
 good performance than IN operartor

 
=> display departments which are empty ?

    SELECT *
    FROM DEPT  D
    WHERE NOT EXISTS (SELECT * FROM EMP WHERE DEPTNO =  D.DEPTNO) ;

     10            ACCTS	        	WHERE NOT EXISTS (WHERE DEPTNO=10)   FALSE
     20           RESEARCH  	WHERE NOT EXISTS (WHERE DEPTNO=20)   FALSE
     30           SALES          	 WHERE NOT EXISTS (WHERE DEPTNO=30)  FALSE
     40           OPERATIONS        WHERE NOT EXISTS (WHERE DEPTNO=40)  TRUE

 using NOT IN :- 
 --------------------

    SELECT *
    FROM DEPT  D
    WHERE  DEPTNO NOT IN (SELECT DEPTNO FROM EMP) ;

 			10
			20
			30

 oracle recommends NOT EXISTS operator than NOT IN operator because NOT EXISTS
 gives good performance than NOT IN operator.

11-dec-23

 Normalization :- 
 ---------------------

 => Normalization is the process of decomposing tables with redundency into number of well
      structured tables.

=> Normalization is set of rules and each rule is called one normal form and there are six normal
     forms

     	1NF
	2NF
	3NF
	BCNF (boyce-codd NF)
	4NF
	5NF

1NF :- 
---------

  => a table said to be in 1NF if there are no multivalued attributes in it or all the attributes
       in table are atomic (single).

      BILL
      BILLNO    BDATE   CCODE   CNAME   CADDR  ICODE  NAME  RATE   QTY  VALUE   TBILL
      100          10-         10             A               HYD      1
					2
					3

					
					20
		
     S	    S	  S	 S	S	M	M     M          M      M          S
    
 
  in the  above table  some of the fields are multivalued , so the table is not according to 1NF
  so decompose the table as follows. 

 TABLE 1 :-

 BILL
 BILLNO  BDATE   CCODE  CNAME  CADDR   TBILL 
-----------
 100
 101
 
TABLE 2 :-

 BILL_ITEMS
 BILLNO   ICODE   NAME   RATE   QTY   VALUE   
-------------------------
  100        1            A	          50 
  100        2
  100        3
  101        1           A	          50
  101        2
  
=> in the above table if ICODE is repeated then NAME,RATE are also repeated , so to reduce
     this redundency apply 2NF.

2NF :- 
----------

  => a table said to be in 2NF 
 
 1  if it is in 1NF 
 2  if there are no partial dependencies in it.

 partial dependency :- 
 ---------------------------

 => in table if non key fields depends on key field then it is called full dependency.
 => in table if non key fields depends on part of the key field then it is called partial dependency.

EX :-

  R(A,B,C,D)         A  => pk

   A ----------> B,C,D (full dependency)

 R(A,B,C,D)            A+B  => pk 

  A,B ---------> C   (full dependecy) 

    B  ---------> D   (partial dependency) 


 TABLE 1 :-

 BILL
 BILLNO  BDATE   CCODE  CNAME  CADDR   TBILL 
-----------

=> above table satisifies 2NF because no partial dependencies in it.

 TABLE 2 :-

 BILL_ITEMS
 BILLNO   ICODE   NAME   RATE   QTY   VALUE   
-------------------------

        BILLNO,ICODE -------------->  QTY ,  VALUE (full dependency)
                     ICODE ---------------> NAME,RATE   (partial dependency)

 => above table contains partial dependency , so the table is not according to 2NF then 
      decompose the table as follows

 TABLE 2 :- 
 --------------

 ITEMS
 ICODE   NAME  RATE
 ----------
 
TABLE 3 :- 
----------------

 BILL_ITEMS
 BILLNO    ICODE     QTY     VALUE
 -----------------------

3NF :- 
---------

 => a table said to be in 3NF 

  1  if it is in 2NF 
  2  if there are no transitive dependencies in it

 Transitive dependency :- 
 --------------------------------

 => in table if non key field depends on another non key field then it is called transitive dependency

  R(A,B,C,D)          A   =>  pk

  A ---------->B,C   (full dependency)

  C------------>D    (transitive dependency) 

 
 TABLE 1 :-

 BILL
 BILLNO  BDATE   CCODE  CNAME  CADDR   TBILL 
-----------

BILLNO  -----------> BDATE,TBILL (full )
CCODE ----------->  CNAME,CADDR (transitive)

=> above table contains transitive dependency , so the table is not according to 3NF then
     decompose the table as follows 

CUST
CCODE	CNAME	CADDR
 ----------

BILL
BILLNO      BDATE          TBILL        CCODE
-----------                           (calculate)

TABLE 2 :- 
 --------------

 ITEMS
 ICODE   NAME  RATE
 ----------
 
TABLE 3 :- 
----------------

 BILL_ITEMS
 BILLNO    ICODE     QTY     VALUE (calculated)
 -----------------------


AFTER 3NF :- 
-------------------

CUST
CCODE   CNAME   CADDR
-----------

BILL
BILLNO   BDATE    CCODE
----------

ITEMS
ICODE   NAME  RATE
---------

BILL_ITEMS
BILLNO   ICODE     QTY
----------------------

=========================================================================